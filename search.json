[{"title":"DASCTF-HDCTF2024 WP","path":"/2024/06/22/DASCTF-HDCTF2024-WP/","content":"baby_rop直接动调，主要代码都在debug003段 先校验长度，rdi存放了输入的长度 观察汇编容易看出，rdi和rsi，rand()异或 异或后如果rdi的值如果为0，zf被置为1，cmovz指令后rdi就会被置为1。 否则将会exit 因此获取rsi和rand()的值异或0x025649DA8^0x025649D88&#x3D;0x20 长度为0x20 重新输入后继续跟，跟到加密逻辑 观察到加密逻辑为先异或key然后加上key 然后又回到这里检验 因为是8个字节加密，直接手动取出每一组rsi和rand()的值，解密拿到flag 123456import libnumkey=0x343230324E494448enc=[0x9A7BA6984AB8636B,0x8F739F7345DC15CF,0x399F7938C150EA1A,0x7D454145674F5DD5]rd=[0x011DB2A3F,0x030836D0F,0x00AD48145,0x01ECB02BB]for i in range(len(enc)): print(libnum.n2s((((enc[i]^rd[i])-key)^key)&amp;0xffffffffffffffff).decode()[::-1],end=&quot;&quot;) FinalEncrypt程序自带加密，找到key就行 在代码中可以看出key和时间关联 属性里面找到时间 动调，修改seed的值 运行拿到key 解密 同理解密flag.md.enc 接着分析Encryption 主要用随机数生成了一个v8，然后就是换表加密 将代码粘贴出，用来生成v8 rand.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&quot;defs.h&quot;int main()&#123;\tunsigned int v3; // eax\tchar Str[8]; // [rsp+20h] [rbp-60h] BYREF\tchar v6[56]; // [rsp+28h] [rbp-58h] BYREF\tint v7; // [rsp+60h] [rbp-20h]\tunsigned char v8[260]; // [rsp+70h] [rbp-10h] BYREF\tint v9; // [rsp+174h] [rbp+F4h]\tint v10; // [rsp+178h] [rbp+F8h]\tint v11; // [rsp+17Ch] [rbp+FCh]\tint v12; // [rsp+180h] [rbp+100h]\tint v13; // [rsp+184h] [rbp+104h]\tint v14; // [rsp+188h] [rbp+108h]\tint v15; // [rsp+18Ch] [rbp+10Ch]\tint v16; // [rsp+190h] [rbp+110h]\tchar v17; // [rsp+195h] [rbp+115h]\tchar v18; // [rsp+196h] [rbp+116h]\tchar v19; // [rsp+197h] [rbp+117h]\tint i; // [rsp+198h] [rbp+118h]\tunsigned __int8 v21; // [rsp+19Ch] [rbp+11Ch]\tchar v22; // [rsp+19Dh] [rbp+11Dh]\tchar v23; // [rsp+19Eh] [rbp+11Eh]\tchar v24; // [rsp+19Fh] [rbp+11Fh]\tscanf(&quot;%d&quot;,&amp;v3);\tsrand(v3);\tdo v19 = rand();\twhile ( !v19 );\tmemset(v8, 0, 0x100);\tv8[0] = v19;\tv22 = 1;\tv21 = 1;\tdo\t&#123; if ( v22 &lt; 0 ) v24 = 27; else v24 = 0; v22 ^= v24 ^ (2 * v22); v18 = (2 * v21) ^ (4 * ((2 * v21) ^ v21)) ^ v21; v17 = v18 ^ (16 * v18); if ( v17 &lt; 0 ) v23 = 9; else v23 = 0; v21 = v23 ^ v17; v16 = (unsigned __int8)(v23 ^ v17); v16 = __ROR1__(v23 ^ v17, 7); v15 = v16 ^ (unsigned __int8)(v21 ^ v8[0]); v14 = v21; v14 = __ROR1__(v21, 6); v13 = v15 ^ v14; v12 = v21; v12 = __ROR1__(v21, 5); v11 = v13 ^ v12; v10 = v21; v10 = __ROR1__(v21, 4); v9 = v11 ^ v10; v8[v22] = v11 ^ v10;\t&#125;\twhile ( v22 != 1 );\tfor(int i=0;i&lt;256;i++) printf(&quot;%d,&quot;,v8[i]);&#125; 因为我c语言不好，所以用的python的subprocess和rand交互拿到v8，然后用python解密 1234567891011121314151617import subprocessfrom tqdm import tqdmenc=list(bytes.fromhex(&#x27;&#x27;&#x27;e07816e1dba1da61536634bef2c3b6346d533cc3b6b834e3beb634c80264143c34e36400bb4daa6902ff643414e3b8344dff6634b8b66db6bbc33834143461ab147e04&#x27;&#x27;&#x27;))for i in tqdm(range(1715156519,-1,-1)): process = subprocess.Popen([&quot;rand.exe&quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE) input_data = str(i) process.stdin.write(input_data.encode()) process.stdin.close() output = process.stdout.read() s=output.decode() v8=list(eval(s)) try: ind=[v8.index(i) for i in enc] print(bytes(ind)) break except: pass"},{"title":"春秋杯冬季赛2023 WP","path":"/2024/06/22/春秋杯冬季赛2023-WP/","content":"coos 这一段生成了密钥，直接取就行了 第一组opcode，0x39只进行了一点初始化操作，主要是后面的[0x4e,0x4f,0x50,0x49]*31。 还原算法0x4e进行了一些初始化后又一个opcode然后进行处理 跑出汇编 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254opcode0=[0x25,0x23,0x28,0x26,0x33]opcode1=[0x00000042, 0x00000000, 0x00000039, 0x00000000, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048, 0x00000049, 0x00000002, 0x00000011, 0x00000002, 0x00000043, 0x00000044, 0x00000001, 0x00000037, 0x0000000F, 0x00000045, 0x0000000C, 0x00000046, 0x00000002, 0x00000047, 0x00000048]opcode2=[0x00000042, 0x00000000, 0x00000039, 0x00000000, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037,0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001,0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A,0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049, 0x00000043,0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D, 0x00000049,0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C, 0x0000004D,0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B, 0x0000004C,0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001, 0x0000004B,0x0000004C, 0x0000004D, 0x00000049, 0x00000043, 0x0000004A, 0x00000001, 0x00000037, 0x00000001,0x0000004B, 0x0000004C, 0x0000004D]ip=0index=1opcode=opcode1while ip&lt;len(opcode): v2=opcode[ip] if v2==0x1: print(&quot;mov eax,ebx&quot;) ip+=1 elif v2==0x2: print(&quot;mov eax,ecx&quot;) ip += 1 elif v2==0x3: print(&quot;mov eax,edx&quot;) ip += 1 elif v2==0x4: print(&quot;mov ebx,eax&quot;) ip += 1 elif v2==0x5: print(&quot;mov ebx,ecx&quot;) ip += 1 elif v2==0x6: print(&quot;mov ebx,edx&quot;) ip += 1 elif v2==0x7: print(&quot;mov ecx,eax&quot;) ip += 1 elif v2==0x8: print(&quot;mov ecx,ebx&quot;) ip += 1 elif v2==0x9: print(&quot;mov ecx,edx&quot;) ip += 1 elif v2==0xa: print(&quot;mov edx,eax&quot;) ip += 1 elif v2==0xb: print(&quot;mov edx,ebx&quot;) ip += 1 elif v2==0xc: print(&quot;mov edx,ecx&quot;) ip += 1 elif v2==0xe: ip += 1 elif v2==0xf: ip += 1 elif v2==0xd: v10=opcode[ip+1] print(&quot;mov edx,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2==0x10: print(&quot;push ebx&quot;) ip += 1 elif v2==0x11: v10=opcode[ip+1] print(&quot;shl eax,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2==0x12: print(&quot;pop ecx&quot;) ip += 1 elif v2==0x13: ip += 1 elif v2==0x14: v10=opcode[ip+1] print(&quot;shr ebx,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2==0x15: print(&quot;pop edx&quot;) ip += 1 elif v2==0x16: ip += 1 elif v2==0x17: ip += 1 elif v2==0x18: print(&quot;add eax,ecx&quot;) ip += 1 elif v2==0x1C or v2==0x19: print(&quot;push eax&quot;) ip += 1 elif v2==0x1E or v2==0x1a: v10=opcode[ip+1] print(&quot;shr eax,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2==0x1b: ip += 1 elif v2==0x1d: ip += 1 elif v2==0x1f: ip += 1 elif v2==0x20: ip += 1 elif v2==0x21: ip += 1 elif v2==0x22: print(&quot;return&quot;) ip += 1 elif v2 == 0x23: print(&quot;pop ebx&quot;) ip += 1 elif v2 == 0x24: print(&quot;add ebx,eax&quot;) ip += 1 elif v2 == 0x25: print(&quot;pop eax&quot;) ip += 1 elif v2==0x26: v10=opcode[ip+1] print(&quot;xor eax,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2 == 0x27: print(&quot;push ecx&quot;) ip += 1 elif v2 == 0x28: print(&quot;xor eax,ebx&quot;) ip += 1 elif v2==0x29: v10=opcode[ip+1] print(&quot;xor ebx,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2 == 0x2A: print(&quot;add ebx,ecx&quot;) ip += 1 elif v2 == 0x2B: print(&quot;xor ebx,ecx&quot;) ip += 1 elif v2 == 0x2c: ip += 2 elif v2 == 0x2d: print(&quot;add eax,ebx&quot;) ip += 1 elif v2 == 0x2f: ip += 2 elif v2 == 0x30: print(&quot;judge&quot;) ip += 1 elif v2 == 0x31: ip += 2 elif v2 == 0x32: ip += 1 elif v2 == 0x33: ip += 2 elif v2 == 0x34: ip += 1 elif v2 == 0x35: ip += 1 elif v2 == 0x36: ip += 1 elif v2==0x37: v10 = opcode[ip + 1] print(&quot;and eax,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2 == 0x38: ip += 1 elif v2==0x39: v10 = opcode[ip + 1] print(&quot;mov ecx,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2==0x3a: v10 = opcode[ip + 1] print(&quot;mov ebx,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2 == 0x3b: ip += 1 elif v2 == 0x3c: ip += 1 elif v2 == 0x3d: print(&quot;shl qword,eax&quot;) ip += 1 elif v2 == 0x3e: ip += 2 elif v2 == 0x3f: ip += 1 elif v2 == 0x40: ip += 1 elif v2 == 0x41: ip += 2 elif v2==0x42: v10=opcode[ip+1] print(&quot;mov dword,&#123;&#125;&quot;.format(v10)) ip+=2 elif v2==0x43: print(&quot;mov ebx,enc&quot;) ip += 1 elif v2==0x44: print(&quot;shr ebx,eax&quot;) ip+=1 elif v2==0x45: print(&quot;mov eb_x,dword_F6E000[2 * ea_x]&quot;) ip+=1 elif v2==0x46: v10 = opcode[ip + 1] print(&quot;shl edx,&#123;&#125;&quot;.format(v10)) ip += 2 elif v2==0x47: print(&quot;shr ebx,edx&quot;) ip+=1 elif v2==0x48: print(&quot;add result,ebx&quot;) ip+=1 elif v2==0x49: print(&quot;inc ecx&quot;) print(&quot;--------------------&quot;+str(index)) index+=1 ip+=1 elif v2 == 0x4a: print(&quot;shr ebx,ecx&quot;) ip += 1 elif v2 == 0x4b: print(&quot;mov ebx,dword_F6E080[2 * ecx]&quot;) ip += 1 elif v2 == 0x4c: print(&quot;shl eax,ebx&quot;) ip += 1 elif v2 == 0x4d: print(&quot;add result,eax&quot;) ip += 1 else: ip+=1pop eaxpop ebxxor eax,ebxxor eax,51 eax和ebx是前面传进来的密文和密钥 只是先将密文和密钥异或后异或了个0x33 0x4f 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208mov dword,0mov ecx,0mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------1mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------2mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------3mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------4mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------5mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------6mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------7mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------8mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------9mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------10mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------11mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------12mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------13mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------14mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebxinc ecx--------------------15mov eax,ecxshl eax,2mov ebx,encshr ebx,eaxmov eax,ebxand eax,15mov eb_x,dword_F6E000[2 * ea_x]mov edx,ecxshl edx,2shr ebx,edxadd result,ebx 打印出汇编看到有个重复的代码块，16轮循环 根据汇编复原算法 0x50 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576mov dword,0mov ecx,0mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------1mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------2mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------3mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------4mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------5mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------6mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------7mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------8mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------9mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------10mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------11mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------12mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------13mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------14mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------15mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------16mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------17mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------18mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------19mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------20mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------21mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------22mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------23mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------24mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------25mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------26mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------27mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------28mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------29mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------30mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------31mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------32mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------33mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------34mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------35mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------36mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------37mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------38mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------39mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------40mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------41mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------42mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------43mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------44mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------45mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------46mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------47mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------48mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------49mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------50mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------51mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------52mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------53mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------54mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------55mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------56mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------57mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------58mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------59mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------60mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------61mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------62mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eaxinc ecx--------------------63mov ebx,encshr ebx,ecxmov eax,ebxand eax,1mov ebx,dword_F6E080[2 * ecx]shl eax,ebxadd result,eax 0x49就计数器加了个1 sub_F71307 发现和0x4e对应的opcode一样 算法1234567891011121314151617181920212223242526272829303132333435363738key=[0x65696368, 0x696C6F76, 0x344B7D10, 0xCEADD4F8, 0x59A5B1DB, 0xCEBF0002, 0x2F3AB735, 0xD1EE63EA, 0xBB3AFC6A, 0xF7EBA4C0, 0x1F47B9F6, 0x0FCB5F04, 0xEFDFAE97, 0x7BAC2E8C, 0x883F2D42, 0x2CE86AE8, 0xB9EEB0A8, 0x98CDB684, 0x94B3A1E3, 0xC8F10A07, 0xEA6336BB, 0xA89E4C0D, 0x7323C479, 0xAD4DC0BA, 0x42A27960, 0xBA2FC2EC, 0xF6B53759, 0x52287D00, 0x96E8BF25, 0x6FC4C7BD, 0x5D48A1C4, 0x84A63D6C, 0x39BF1354, 0x3C37F712, 0xCA1298E3, 0xE4A9BB13, 0x04F0DFA7, 0xA551883F, 0xE392A6B7, 0x138696DA, 0x4E954623, 0x1CFCE1EF, 0xFC4E1A5F, 0xA7EB1762, 0x9873F3DF, 0x22BFD0AA, 0x129FAC47, 0x19174775, 0x808AFF42, 0x1A834072, 0x60645D1C, 0x943851D7, 0xA06A0D46, 0x32BD54D0, 0x2250E153, 0x7AC4490F, 0x2CCAF560, 0xD0653554, 0x29EB1142, 0xC414628E, 0xF34194B8, 0x01C3F8BA, 0x43105185, 0xCB51F952]enc=[0x67616C66,0x5954657B]dword=[0x00000002, 0x00000000, 0x00000001, 0x00000000, 0x00000007, 0x00000000, 0x00000004, 0x00000000, 0x00000008, 0x00000000, 0x0000000F, 0x00000000, 0x0000000E, 0x00000000, 0x00000003, 0x00000000, 0x0000000D, 0x00000000, 0x0000000A, 0x00000000, 0x00000000, 0x00000000, 0x00000009, 0x00000000, 0x0000000B, 0x00000000, 0x00000006, 0x00000000, 0x00000005, 0x00000000, 0x0000000C, 0x00000000]dword2=[0x0000003F, 0x00000000, 0x0000002F, 0x00000000, 0x0000001F, 0x00000000, 0x0000000F, 0x00000000, 0x0000003E, 0x00000000, 0x0000002E, 0x00000000, 0x0000001E, 0x00000000, 0x0000000E, 0x00000000, 0x0000003D, 0x00000000, 0x0000002D, 0x00000000, 0x0000001D, 0x00000000, 0x0000000D, 0x00000000, 0x0000003C, 0x00000000, 0x0000002C, 0x00000000, 0x0000001C, 0x00000000, 0x0000000C, 0x00000000, 0x0000003B, 0x00000000, 0x0000002B, 0x00000000, 0x0000001B, 0x00000000, 0x0000000B, 0x00000000, 0x0000003A, 0x00000000, 0x0000002A, 0x00000000, 0x0000001A, 0x00000000, 0x0000000A, 0x00000000, 0x00000039, 0x00000000, 0x00000029, 0x00000000, 0x00000019, 0x00000000, 0x00000009, 0x00000000, 0x00000038, 0x00000000, 0x00000028, 0x00000000, 0x00000018, 0x00000000, 0x00000008, 0x00000000, 0x00000037, 0x00000000, 0x00000027, 0x00000000, 0x00000017, 0x00000000, 0x00000007, 0x00000000, 0x00000036, 0x00000000, 0x00000026, 0x00000000, 0x00000016, 0x00000000, 0x00000006, 0x00000000, 0x00000035, 0x00000000, 0x00000025, 0x00000000, 0x00000015, 0x00000000, 0x00000005, 0x00000000, 0x00000034, 0x00000000, 0x00000024, 0x00000000, 0x00000014, 0x00000000, 0x00000004, 0x00000000, 0x00000033, 0x00000000, 0x00000023, 0x00000000, 0x00000013, 0x00000000, 0x00000003, 0x00000000, 0x00000032, 0x00000000, 0x00000022, 0x00000000, 0x00000012, 0x00000000, 0x00000002, 0x00000000, 0x00000031, 0x00000000, 0x00000021, 0x00000000, 0x00000011, 0x00000000, 0x00000001, 0x00000000, 0x00000030, 0x00000000, 0x00000020, 0x00000000, 0x00000010, 0x00000000, 0x00000000, 0x00000000]eax=0result=0result1=0for k in range(31): enc[0]^=key[2*k] enc[1]^=key[2*k+1] qenc = enc[1] &lt;&lt; 32 | enc[0] qenc ^= 0x33 result=0 for i in range(16): eax=(i&lt;&lt;2)&amp;0xffffffffffffffff ebx=qenc&gt;&gt;eax ebx&amp;=15 ebx=dword[2*ebx] ecx=i&lt;&lt;2 ebx=ebx&lt;&lt;ecx result+=ebx result1=0 for i in range(64): ebx=result&gt;&gt;i eax=ebx&amp;1 ebx=dword2[2*i] eax=eax&lt;&lt;ebx result1+=eax enc = [result1 &amp; 0xffffffff, result1 &gt;&gt; 32]get=[result1&amp;0xffffffff,result1&gt;&gt;32]key=[0x43105185,0x0CB51F952]for i in range(len(get)): get[i]^=key[i]get[0]^=0x33for i in get: print(hex(i)) 解密1234567891011121314151617181920212223242526272829303132333435363738394041enc=[0xCE40E599,0x9C149C0F,0xCD759C04,0xDF4C680D,0xE52E3DC0,0xBBAFB056,0xB8F527CB,0x8E299C86]keys=[0x65696368, 0x696C6F76, 0x344B7D10, 0xCEADD4F8, 0x59A5B1DB, 0xCEBF0002, 0x2F3AB735, 0xD1EE63EA, 0xBB3AFC6A, 0xF7EBA4C0, 0x1F47B9F6, 0x0FCB5F04, 0xEFDFAE97, 0x7BAC2E8C, 0x883F2D42, 0x2CE86AE8, 0xB9EEB0A8, 0x98CDB684, 0x94B3A1E3, 0xC8F10A07, 0xEA6336BB, 0xA89E4C0D, 0x7323C479, 0xAD4DC0BA, 0x42A27960, 0xBA2FC2EC, 0xF6B53759, 0x52287D00, 0x96E8BF25, 0x6FC4C7BD, 0x5D48A1C4, 0x84A63D6C, 0x39BF1354, 0x3C37F712, 0xCA1298E3, 0xE4A9BB13, 0x04F0DFA7, 0xA551883F, 0xE392A6B7, 0x138696DA, 0x4E954623, 0x1CFCE1EF, 0xFC4E1A5F, 0xA7EB1762, 0x9873F3DF, 0x22BFD0AA, 0x129FAC47, 0x19174775, 0x808AFF42, 0x1A834072, 0x60645D1C, 0x943851D7, 0xA06A0D46, 0x32BD54D0, 0x2250E153, 0x7AC4490F, 0x2CCAF560, 0xD0653554, 0x29EB1142, 0xC414628E, 0xF34194B8, 0x01C3F8BA, 0x43105185, 0xCB51F952]dword=[0x00000002, 0x00000000, 0x00000001, 0x00000000, 0x00000007, 0x00000000, 0x00000004, 0x00000000, 0x00000008, 0x00000000, 0x0000000F, 0x00000000, 0x0000000E, 0x00000000, 0x00000003, 0x00000000, 0x0000000D, 0x00000000, 0x0000000A, 0x00000000, 0x00000000, 0x00000000, 0x00000009, 0x00000000, 0x0000000B, 0x00000000, 0x00000006, 0x00000000, 0x00000005, 0x00000000, 0x0000000C, 0x00000000]table1=[]for i in range(len(dword)): if i%2==0: table1.append(dword[i])dword2=[0x0000003F, 0x00000000, 0x0000002F, 0x00000000, 0x0000001F, 0x00000000, 0x0000000F, 0x00000000, 0x0000003E, 0x00000000, 0x0000002E, 0x00000000, 0x0000001E, 0x00000000, 0x0000000E, 0x00000000, 0x0000003D, 0x00000000, 0x0000002D, 0x00000000, 0x0000001D, 0x00000000, 0x0000000D, 0x00000000, 0x0000003C, 0x00000000, 0x0000002C, 0x00000000, 0x0000001C, 0x00000000, 0x0000000C, 0x00000000, 0x0000003B, 0x00000000, 0x0000002B, 0x00000000, 0x0000001B, 0x00000000, 0x0000000B, 0x00000000, 0x0000003A, 0x00000000, 0x0000002A, 0x00000000, 0x0000001A, 0x00000000, 0x0000000A, 0x00000000, 0x00000039, 0x00000000, 0x00000029, 0x00000000, 0x00000019, 0x00000000, 0x00000009, 0x00000000, 0x00000038, 0x00000000, 0x00000028, 0x00000000, 0x00000018, 0x00000000, 0x00000008, 0x00000000, 0x00000037, 0x00000000, 0x00000027, 0x00000000, 0x00000017, 0x00000000, 0x00000007, 0x00000000, 0x00000036, 0x00000000, 0x00000026, 0x00000000, 0x00000016, 0x00000000, 0x00000006, 0x00000000, 0x00000035, 0x00000000, 0x00000025, 0x00000000, 0x00000015, 0x00000000, 0x00000005, 0x00000000, 0x00000034, 0x00000000, 0x00000024, 0x00000000, 0x00000014, 0x00000000, 0x00000004, 0x00000000, 0x00000033, 0x00000000, 0x00000023, 0x00000000, 0x00000013, 0x00000000, 0x00000003, 0x00000000, 0x00000032, 0x00000000, 0x00000022, 0x00000000, 0x00000012, 0x00000000, 0x00000002, 0x00000000, 0x00000031, 0x00000000, 0x00000021, 0x00000000, 0x00000011, 0x00000000, 0x00000001, 0x00000000, 0x00000030, 0x00000000, 0x00000020, 0x00000000, 0x00000010, 0x00000000, 0x00000000, 0x00000000]table=[]for i in range(len(dword2)): if i%2==0: table.append(dword2[i])for item in range(0,len(enc),2): m=enc[item:item+2] m[0]^=0x33 key=[0x43105185,0x0CB51F952] for i in range(len(m)): m[i]^=key[i] keyindex=60 for k in range(31): get=m[1]&lt;&lt;32 | m[0] ans=[0]*64 c=list(bin(get)[2:].rjust(64,&quot;0&quot;)) for i in range(len(c)): if c[i]==&quot;1&quot;: ans[table.index(i)]=1 ans1=&quot;&quot; for i in range(0,64,4): ins=&quot;&quot;.join(map(str,ans[i:i+4])) ans1+=bin(table1.index(int(ins,2)))[2:].rjust(4,&quot;0&quot;) flag=int(ans1,2) m=[flag&amp;0xffffffff,flag&gt;&gt;32] m[0]^=0x33 m[0]^=keys[keyindex] m[1]^=keys[keyindex+1] keyindex-=2 for i in m: print(bytes.fromhex(hex(i)[2:].rjust(8,&quot;0&quot;)).decode()[::-1],end=&quot;&quot;)#a9d99caef9ae999a299129c91299fc95 upx2023改特征值后工具脱壳 猜测flag头为“flag{”然后爆破种子，异或得到乱序flag 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123;\tint ans[]=&#123;111,24,236,196,58&#125;;\tint rands[5]=&#123;0&#125;;\tint seed;\tfor(seed=1705742545;seed&gt;0;seed--)\t&#123; srand(seed); for(int j=0;j&lt;5;j++) rands[j]=rand()%255; if(rands[0]==ans[0]&amp;&amp;rands[1]==ans[1]&amp;&amp;rands[2]==ans[2]&amp;&amp;rands[3]==ans[3]&amp;&amp;rands[4]==ans[4]) &#123; printf(&quot;%d &quot;,seed); break; &#125;\t&#125;\tint data[]=&#123;0x00000009, 0x00000063, 0x000000D9, 0x000000F6, 0x00000058, 0x000000DD, 0x0000003F, 0x0000004C, 0x0000000F, 0x0000000B, 0x00000098, 0x000000C6, 0x00000065, 0x00000021, 0x00000041, 0x000000ED, 0x000000C4, 0x0000000B, 0x0000003A, 0x0000007B, 0x000000E5, 0x00000075, 0x0000005D, 0x000000A9, 0x00000031, 0x00000041, 0x000000D7, 0x00000052, 0x0000006C, 0x0000000A, 0x000000FA, 0x000000FD, 0x000000FA, 0x00000084, 0x000000DB, 0x00000089, 0x000000CD, 0x0000007E, 0x00000027, 0x00000085, 0x00000013, 0x00000008&#125;;\tsrand(seed);\tfor(int i=0;i&lt;42;i++) printf(&quot;%c&quot;,((rand()%255)^data[i])&amp;0xff);&#125; 还有个交换算法，直接输入测试明文（ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnop）动调得到测试密文（AEIMQUYcgkoBDFHJLNPRTVXZbdfhjlnpCGKOSWaeim） 根据测试明文和测试密文还原密文顺序得到flag 123456test=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnop&quot;get=&quot;AEIMQUYcgkoBDFHJLNPRTVXZbdfhjlnpCGKOSWaeim&quot;enc=&quot;f&#123;52bgb-281lg00ff-46f7-ca009c8e&#125;a381-b7191&quot;for i in test: print(enc[get.index(i)],end=&quot;&quot;)#flag&#123;0305f8f2-14b6-fg7b-bc7a-010299c881e1&#125; file_encryptortls和main里面有异常处理，tls里还有反调试，直接jmp全部跳了 去掉main和loc_401320中的call花指令 分析代码 用cff查看导出dll的输出函数和序列号 百度发现这是微软的CryptoAPI库 根据序列号容易找到加密函数，将其改成解密后动调就能拿到flag，其中1.txt要放在exe同目录下的document文件夹里。 foremost分离出个压缩包 脚本提取文件名复原出一个压缩包 123456789101112131415import zipfileimport base64zipf=zipfile.ZipFile(&#x27;外卖箱.zip&#x27;)dic=&#123;&#125;for item in zipf.infolist(): name=item.filename.encode(&#x27;cp437&#x27;).decode(&#x27;gbk&#x27;) if &#x27;用户&#x27; in name: get=name[6:].split(&#x27;_&#x27;) dic[int(get[0])]=get[1][:-3]out=&#x27;UEsD&#x27;for id in sorted(dic.keys()): out+=dic[id].replace(&#x27;-&#x27;, &#x27;/&#x27;).strip()open(&#x27;out.zip&#x27;,&#x27;wb&#x27;).write(base64.b64decode(out)) txt中找到第一段flag 将钥匙.png用bandzip压缩后对外卖箱进行明文攻击 拿到第二段flag 拼接得到flag"},{"title":"海大CTF2024 WP","path":"/2024/06/22/海大CTF2024-WP/","content":"贪吃蛇动调先找到一条关键命令，用来修改标签的分数，因此可以知道关键逻辑在wasm中 命令从wasm内存中提取 ptr就是内存中的地址，找到对应区域，在附近找到存放分数的内存 修改内存的值为114514拿到flag #flag{sNAke_ca5e_1s_g0Od_6871366791258318} 爆率真的高找到0.9999，联想到概率为0.0001，可知这里大概率是判断逻辑 将0.9999删掉 查看控制台，发现一直在清除数据 动调测试发现是_0x4d3fb4()，删掉 打开后在控制台拿到flag #flag{consolecon} xor+不想看逻辑了，直接套逐位爆破板子 1234567891011121314151617181920212223242526import subprocessfrom string import printablefile = &quot;xorpp&quot;data=list(open(file,&quot;rb&quot;).read())addr=0x06B3base=&quot;&quot;for i in range(0x24+1): data[addr]=i open(file,&quot;wb&quot;).write(bytes(data)) found=False for j in printable: try_data = (base+j) process = subprocess.Popen([file], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) input_bytes = try_data.encode(&#x27;utf-8&#x27;) process.stdin.write(input_bytes) process.stdin.flush() output, error = process.communicate() s = output.decode(&#x27;gbk&#x27;) if &quot;right&quot; in s: base=try_data print(&quot;[+]&quot;+try_data) found=True break if not found: print(&quot;[-]not found&quot;) exit() #flag{buT_diff1cultY_w0nt_ch4Nge_muCh} 钩子去反调试 遍历执行的函数找到关键代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445from ida_hexrays import *from ida_dbg import *from idaapi import *from idautils import *from idc import *from ida_kernwin import *funends=[]stack=[]class dbg_hooks_t(ida_dbg.DBG_Hooks): &#x27;&#x27;&#x27;继承自父类DBG_Hooks&#x27;&#x27;&#x27; def __init__(self): ida_dbg.DBG_Hooks.__init__(self) def dbg_suspend_process(self): print(get_func_name(here())+&quot;\\t&quot;+str(find_func_end(here())-here())) del_bpt(here()) continue_process()&#x27;&#x27;&#x27;安装/卸载钩子&#x27;&#x27;&#x27;if &#x27;tmp_dbg_hooks&#x27; not in dir(): for seg in Segments(): segname = get_segm_name(seg) segstart = get_segm_start(seg) segend = get_segm_end(seg) if (segname == &#x27;.text&#x27;): for funcaddr in Functions(segstart, segend): funname = get_func_name(funcaddr) add_bpt(funcaddr) print(funname + &quot;:&quot; + hex(funcaddr)) tmp_dbg_hooks = dbg_hooks_t() tmp_dbg_hooks.hook() print(&#x27;[+] tmp dbg hook success&#x27;)else: for seg in Segments(): segname = get_segm_name(seg) segstart = get_segm_start(seg) segend = get_segm_end(seg) if (segname == &#x27;.text&#x27;): for funcaddr in Functions(segstart, segend): funname = get_func_name(funcaddr) del_bpt(funcaddr) tmp_dbg_hooks = dbg_hooks_t() tmp_dbg_hooks.unhook() del tmp_dbg_hooks print(&#x27;[+] tmp dbg unhook success&#x27;) 解密得到flag 12345678910111213141516171819202122v10=[0]*256for i in range(256): v10[i]=ikey=[0x88, 0xE3, 0xEE, 0x11, 0xC6, 0x49, 0x74, 0xA5, 0xDD, 0x98, 0x59, 0xE9, 0x48, 0xF7, 0x6E, 0xBF, 0x3A, 0xB3, 0x9B, 0xDF, 0x10, 0x42, 0xFF, 0x99, 0x6C, 0xE3, 0x3E, 0x05, 0x2C, 0x65, 0x47, 0xEF]v9=0for j in range(256): v9=(key[j%0x20]+v10[j]+v9)%256 v10[v9],v10[j]=v10[j],v10[v9]v6=0v8=0enc=[2, 204, 71, 179, 77, 108, 253, 154, 76, 78, 212, 139, 30, 129, 25, 10, 52, 38, 208, 255, 112, 182, 176, 146, 73, 179, 0, 0]for k in range(len(enc)): v6=(v6+1)%256 v8=(v10[v6]+v8)%256 v10[v8], v10[v6] = v10[v6], v10[v8] enc[k]^=v10[(v10[v8]+v10[v6])%256]print(&quot;&quot;.join(map(chr,enc))) #flag{ho00OoOoOoked_gotcha} 睡Litefile查看为Inter Hex文件 hex2bin转成bin文件 avr架构单片机，用ida打开 拼接得到flag #flag{dEl4y_n0_MoR3}"},{"title":"NKCTF2024 WP","path":"/2024/06/22/NKCTF2024-WP/","content":"login_systemz3解方程，换表aes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371from z3 import *import binasciiimport reimport hashlibx = Solver()ans=[]a1 = [Int(&#x27;%d&#x27;%i) for i in range(16)]x.add(a1[2] + a1[1] + a1[0] + a1[3] == 447 , 101 * a1[2] + a1[0] + 9 * a1[1] + 8 * a1[3] == 12265 , 5 * a1[2] + 3 * a1[0] + 4 * a1[1] + 6 * a1[3] == 2000 , 88 * a1[2] + 12 * a1[0] + 11 * a1[1] + 87 * a1[3] == 21475 , a1[6] + 59 * a1[5] + 100 * a1[4] + a1[7] == 7896 , 443 * a1[4] + 200 * a1[5] + 10 * a1[6] + 16 * a1[7] == 33774 , 556 * a1[5] + 333 * a1[4] + 8 * a1[6] + 7 * a1[7] == 44758 , a1[6] + a1[5] + 202 * a1[4] + a1[7] == 9950 , 78 * a1[10] + 35 * a1[9] + 23 * a1[8] + 89 * a1[11] == 24052 , 78 * a1[8] + 59 * a1[9] + 15 * a1[10] + 91 * a1[11] == 25209 , 111 * a1[10] + 654 * a1[9] + 123 * a1[8] + 222 * a1[11] == 113427 , 6 * a1[9] + 72 * a1[8] + 5 * a1[10] + 444 * a1[11] == 54166 , 56 * a1[14] + 35 * a1[12] + 6 * a1[13] + 121 * a1[15] == 11130 , 169 * a1[14] + 158 * a1[13] + 98 * a1[12] + 124 * a1[15] == 27382 , 147 * a1[13] + 65 * a1[12] + 131 * a1[14] + 129 * a1[15] == 23564 , 137 * a1[14] + 132 * a1[13] + 620 * a1[12] + 135 * a1[15] == 51206)if x.check() == sat: model = x.model() for i in range(16): ans.append(model[a1[i]].as_long().real)username=&quot;&quot;.join(map(chr,ans))print(username)enc1=[0x7E, 0x5A, 0x6E, 0x77, 0x3A, 0x79, 0x35, 0x76, 0x7C]pre_pass=&quot;&quot;for i in range(len(enc1)): pre_pass+=chr((enc1[i]-9+i)^i)print(pre_pass)class AES:#128-ECB sbox = [0x31, 0x52, 0x5A, 0xC8, 0x0B, 0xAC, 0xF3, 0x3A, 0x8B, 0x54, 0x27, 0x9B, 0xAB, 0x95, 0xDE, 0x83, 0x60, 0xCB, 0x53, 0x7F, 0xC4, 0xE3, 0x0A, 0x97, 0xE0, 0x29, 0xD5, 0x68, 0xC5, 0xDF, 0xF4, 0x7B, 0xAA, 0xD6, 0x42, 0x78, 0x6C, 0xE9, 0x70, 0x17, 0xD7, 0x37, 0x24, 0x49, 0x75, 0xA9, 0x89, 0x67, 0x03, 0xFA, 0xD9, 0x91, 0xB4, 0x5B, 0xC2, 0x4E, 0x92, 0xFC, 0x46, 0xB1, 0x73, 0x08, 0xC7, 0x74, 0x09, 0xAF, 0xEC, 0xF5, 0x4D, 0x2D, 0xEA, 0xA5, 0xDA, 0xEF, 0xA6, 0x2B, 0x7E, 0x0C, 0x8F, 0xB0, 0x04, 0x06, 0x62, 0x84, 0x15, 0x8E, 0x12, 0x1D, 0x44, 0xC0, 0xE2, 0x38, 0xD4, 0x47, 0x28, 0x45, 0x6E, 0x9D, 0x63, 0xCF, 0xE6, 0x8C, 0x18, 0x82, 0x1B, 0x2C, 0xEE, 0x87, 0x94, 0x10, 0xC1, 0x20, 0x07, 0x4A, 0xA4, 0xEB, 0x77, 0xBC, 0xD3, 0xE1, 0x66, 0x2A, 0x6B, 0xE7, 0x79, 0xCC, 0x86, 0x16, 0xD0, 0xD1, 0x19, 0x55, 0x3C, 0x9F, 0xFB, 0x30, 0x98, 0xBD, 0xB8, 0xF1, 0x9E, 0x61, 0xCD, 0x90, 0xCE, 0x7C, 0x8D, 0x57, 0xAE, 0x6A, 0xB3, 0x3D, 0x76, 0xA7, 0x71, 0x88, 0xA2, 0xBA, 0x4F, 0x3E, 0x40, 0x64, 0x0F, 0x48, 0x21, 0x35, 0x36, 0x2F, 0xE8, 0x14, 0x5D, 0x51, 0xD8, 0xB5, 0xFE, 0xD2, 0x96, 0x93, 0xA1, 0xB6, 0x43, 0x0D, 0x4C, 0x80, 0xC9, 0xFF, 0xA3, 0xDD, 0x72, 0x05, 0x59, 0xBF, 0x0E, 0x26, 0x34, 0x1F, 0x13, 0xE5, 0xDC, 0xF2, 0xC6, 0x50, 0x1E, 0xE4, 0x85, 0xB7, 0x39, 0x8A, 0xCA, 0xED, 0x9C, 0xBB, 0x56, 0x23, 0x1A, 0xF0, 0x32, 0x58, 0xB2, 0x65, 0x33, 0x6F, 0x41, 0xBE, 0x3F, 0x6D, 0x11, 0x00, 0xAD, 0x5F, 0xC3, 0x81, 0x25, 0xA8, 0xA0, 0x9A, 0xF6, 0xF7, 0x5E, 0x99, 0x22, 0x2E, 0x4B, 0xF9, 0x3B, 0x02, 0x7A, 0xB9, 0x5C, 0x69, 0xF8, 0x1C, 0xDB, 0x01, 0x7D, 0xFD] s_box = &#123;&#125; ns_box = &#123; &#125; Rcon = &#123; 1: [&#x27;0x01&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 2: [&#x27;0x02&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 3: [&#x27;0x04&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 4: [&#x27;0x08&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 5: [&#x27;0x10&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 6: [&#x27;0x20&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 7: [&#x27;0x40&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 8: [&#x27;0x80&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 9: [&#x27;0x1B&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 10: [&#x27;0x36&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;] &#125; Matrix = [ [&#x27;0x02&#x27;, &#x27;0x03&#x27;, &#x27;0x01&#x27;, &#x27;0x01&#x27;], [&#x27;0x01&#x27;, &#x27;0x02&#x27;, &#x27;0x03&#x27;, &#x27;0x01&#x27;], [&#x27;0x01&#x27;, &#x27;0x01&#x27;, &#x27;0x02&#x27;, &#x27;0x03&#x27;], [&#x27;0x03&#x27;, &#x27;0x01&#x27;, &#x27;0x01&#x27;, &#x27;0x02&#x27;] ] ReMatrix = [ [&#x27;0x0e&#x27;, &#x27;0x0b&#x27;, &#x27;0x0d&#x27;, &#x27;0x09&#x27;], [&#x27;0x09&#x27;, &#x27;0x0e&#x27;, &#x27;0x0b&#x27;, &#x27;0x0d&#x27;], [&#x27;0x0d&#x27;, &#x27;0x09&#x27;, &#x27;0x0e&#x27;, &#x27;0x0b&#x27;], [&#x27;0x0b&#x27;, &#x27;0x0d&#x27;, &#x27;0x09&#x27;, &#x27;0x0e&#x27;] ] plaintext = [[], [], [], []] plaintext1 = [[], [], [], []] subkey = [[], [], [], []] def __init__(self, key):#密钥扩展 self.s_box = dict(zip([&quot;0x%02x&quot;%i for i in range(256)], [&quot;0x%02x&quot;%i for i in self.sbox])) self.ns_box = dict(zip(self.s_box.values(), self.s_box.keys())) for i in range(4): for j in range(0, 8, 2): self.subkey[i].append(&quot;0x&quot; + key[i * 8 + j:i * 8 + j + 2]) # print(self.subkey) for i in range(4, 44): if i % 4 != 0: tmp = xor_32(self.subkey[i - 1], self.subkey[i - 4],0) self.subkey.append(tmp) else: # 4的倍数的时候执行 tmp1 = self.subkey[i - 1][1:] tmp1.append(self.subkey[i - 1][0]) # print(tmp1) for m in range(4): tmp1[m] = self.s_box[tmp1[m]] # tmp1 = self.s_box[&#x27;cf&#x27;] tmp1 = xor_32(tmp1, self.Rcon[i / 4], 0) self.subkey.append(xor_32(tmp1, self.subkey[i - 4],0)) def AddRoundKey(self, round):#轮密钥加 for i in range(4): self.plaintext[i] = xor_32(self.plaintext[i], self.subkey[round * 4 + i],0) # print(&#x27;AddRoundKey&#x27;,self.plaintext) def PlainSubBytes(self): for i in range(4): for j in range(4): self.plaintext[i][j] = self.s_box[self.plaintext[i][j]] # print(&#x27;PlainSubBytes&#x27;,self.plaintext) def RePlainSubBytes(self): for i in range(4): for j in range(4): self.plaintext[i][j] = self.ns_box[self.plaintext[i][j]] def ShiftRows(self):#行移位 p1, p2, p3, p4 = self.plaintext[0][1], self.plaintext[1][1], self.plaintext[2][1], self.plaintext[3][1] self.plaintext[0][1] = p2 self.plaintext[1][1] = p3 self.plaintext[2][1] = p4 self.plaintext[3][1] = p1 p1, p2, p3, p4 = self.plaintext[0][2], self.plaintext[1][2], self.plaintext[2][2], self.plaintext[3][2] self.plaintext[0][2] = p3 self.plaintext[1][2] = p4 self.plaintext[2][2] = p1 self.plaintext[3][2] = p2 p1, p2, p3, p4 = self.plaintext[0][3], self.plaintext[1][3], self.plaintext[2][3], self.plaintext[3][3] self.plaintext[0][3] = p4 self.plaintext[1][3] = p1 self.plaintext[2][3] = p2 self.plaintext[3][3] = p3 # print(&#x27;ShiftRows&#x27;,self.plaintext) def ReShiftRows(self): p1, p2, p3, p4 = self.plaintext[0][1], self.plaintext[1][1], self.plaintext[2][1], self.plaintext[3][1] self.plaintext[3][1] = p3 self.plaintext[2][1] = p2 self.plaintext[0][1] = p4 self.plaintext[1][1] = p1 p1, p2, p3, p4 = self.plaintext[0][2], self.plaintext[1][2], self.plaintext[2][2], self.plaintext[3][2] self.plaintext[0][2] = p3 self.plaintext[1][2] = p4 self.plaintext[2][2] = p1 self.plaintext[3][2] = p2 p1, p2, p3, p4 = self.plaintext[0][3], self.plaintext[1][3], self.plaintext[2][3], self.plaintext[3][3] self.plaintext[0][3] = p2 self.plaintext[1][3] = p3 self.plaintext[2][3] = p4 self.plaintext[3][3] = p1 def MixColumns(self):#列混淆 for i in range(4): for j in range(4): self.plaintext1[i].append(MatrixMulti(self.Matrix[j], self.plaintext[i])) # print(&#x27;MixColumns&#x27;,self.plaintext1) def ReMixColumns(self): for i in range(4): for j in range(4): self.plaintext1[i].append(MatrixMulti(self.ReMatrix[j], self.plaintext[i])) def AESEncryption(self, plaintext): self.plaintext = [[], [], [], []] for i in range(4): for j in range(0, 8, 2): self.plaintext[i].append(&quot;0x&quot; + plaintext[i * 8 + j:i * 8 + j + 2]) self.AddRoundKey(0) for i in range(9): self.PlainSubBytes() self.ShiftRows() self.MixColumns() self.plaintext = self.plaintext1 self.plaintext1 = [[], [], [], []] self.AddRoundKey(i + 1) self.PlainSubBytes() self.ShiftRows() self.AddRoundKey(10) return Matrixtostr(self.plaintext) def AESDecryption(self, cipher): self.plaintext = [[], [], [], []] for i in range(4): for j in range(0, 8, 2): self.plaintext[i].append(&#x27;0x&#x27; + cipher[i * 8 + j:i * 8 + j + 2]) # print(self.ns_box) self.AddRoundKey(10) for i in range(9): self.ReShiftRows() self.RePlainSubBytes() self.AddRoundKey(9-i) self.ReMixColumns() self.plaintext = self.plaintext1 self.plaintext1 = [[], [], [], []] self.ReShiftRows() self.RePlainSubBytes() self.AddRoundKey(0) return Matrixtostr(self.plaintext) def Encryption(self, text): group = PlaintextGroup(TextToByte(text), 32, 1) # print(group) cipher = &quot;&quot; for i in range(len(group)): cipher = cipher + self.AESEncryption(group[i]) return cipher def Decryption(self, cipher): group = PlaintextGroup(cipher, 32, 0) # print(group) text = &#x27;&#x27; for i in range(len(group)): text = text + self.AESDecryption(group[i]) text = ByteToText(text) return textdef xor_32(start, end, key): a = [] for i in range(0, 4): xor_tmp = &quot;&quot; b = hextobin(start[i]) c = hextobin(end[i]) d = bin(key)[2:].rjust(8,&#x27;0&#x27;) for j in range(8): tmp = int(b[j], 10) ^ int(c[j], 10) ^ int(d[j],10) xor_tmp += str(tmp ) a.append(bintohex(xor_tmp)) return adef xor_8(begin, end): xor_8_tmp = &quot;&quot; for i in range(8): xor_8_tmp += str(int(begin[i]) ^ int(end[i])) return xor_8_tmpdef hextobin(word): word = bin(int(word, 16))[2:] for i in range(0, 8-len(word)): word = &#x27;0&#x27;+word return worddef bintohex(word): word = hex(int(word, 2)) if len(word) == 4: return word elif len(word) &lt; 4: return word.replace(&#x27;x&#x27;, &#x27;x0&#x27;)def MatrixMulti(s1, s2): result = [] s3 = [] for i in range(4): s3.append(hextobin(s2[i])) for i in range(4): result.append(MultiProcess(int(s1[i], 16), s3[i])) for i in range(3): result[0] = xor_8(result[0], result[i+1]) return bintohex(result[0])def MultiProcess(a, b): if a == 1: return b elif a == 2: if b[0] == &#x27;0&#x27;: b = b[1:] + &#x27;0&#x27; else: b = b[1:] + &#x27;0&#x27; b = xor_8(b, &#x27;00011011&#x27;) return b elif a == 3: tmp_b = b if b[0] == &#x27;0&#x27;: b = b[1:] + &#x27;0&#x27; else: b = b[1:] + &#x27;0&#x27; b = xor_8(b, &#x27;00011011&#x27;) return xor_8(b, tmp_b) elif a == 9: tmp_b = b return xor_8(tmp_b, MultiProcess(2, MultiProcess(2, MultiProcess(2, b)))) elif a == 11: tmp_b = b return xor_8(tmp_b, xor_8(MultiProcess(2, MultiProcess(2, MultiProcess(2, b))), MultiProcess(2, b))) elif a == 13: tmp_b = b return xor_8(tmp_b, xor_8(MultiProcess(2, MultiProcess(2, MultiProcess(2, b))), MultiProcess(2, MultiProcess(2, b)))) elif a == 14: return xor_8(MultiProcess(2, b), xor_8(MultiProcess(2, MultiProcess(2, MultiProcess(2, b))), MultiProcess(2, MultiProcess(2, b))))def Matrixtostr(matrix): result = &quot;&quot; for i in range(4): for j in range(4): result += matrix[i][j][2:] return resultdef PlaintextGroup(plaintext, length, flag): group = re.findall(&#x27;.&#123;&#x27;+str(length)+&#x27;&#125;&#x27;, plaintext) group.append(plaintext[len(group)*length:]) if group[-1] == &#x27;&#x27; and flag: group[-1] = &#x27;16161616161616161616161616161616&#x27; elif len(group[-1]) &lt; length and flag: tmp = int((length-len(group[-1])) / 2) if tmp &lt; 10: for i in range(tmp): group[-1] = group[-1] + &#x27;0&#x27;+str(tmp) else: for i in range(tmp): group[-1] = group[-1] + str(tmp) elif not flag: del group[-1] return group#字符串转16进制def TextToByte(words): text = words.encode(&#x27;utf-8&#x27;).hex() return textdef ByteToText(encode): tmp = int(encode[-2:]) word = &#x27;&#x27; for i in range(len(encode)-tmp*2): word = word + encode[i] # print(word) word = bytes.decode(binascii.a2b_hex(word)) return word#字节非轮异或def xorbytes(bytes1,bytes2): length=min(len(bytes1),len(bytes2)) output=bytearray() for i in range(length): output.append(bytes1[i]^bytes2[i]) return bytes(output)res=&#x27;B0CC93EAE92FEF5699396E023B4F9E42&#x27;.lower()key = &#x27;&#x27;for i in username: key+=hex(ord(i))[2:].rjust(2,&quot;0&quot;)A1 = AES(key)tail_pass=&quot;&quot;for i in range(0,len(res),32): tail_pass+=bytes.fromhex(A1.AESDecryption(res[i:i+32])).decode()print(tail_pass)print(hashlib.md5(str(username+pre_pass+&quot;_&quot;+tail_pass).encode(&quot;utf-8&quot;)).hexdigest()) NKCTF{2961bba0add6265ba83bc6198e0ec758} REEZ复现算法后z3求解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175from z3 import *x = Solver()num=25ans=[]v20 = [BitVec((&#x27;%d&#x27; % i),8) for i in range(25)]v45=v20[0]v44=v20[1]v43=v20[2]v42=v20[3]v41=v20[4]v40=v20[5]v39=v20[6]v38=v20[7]v37=v20[8]v36=v20[9]v35=v20[10]v34=v20[11]v33=v20[12]v32=v20[13]v31=v20[14]v30=v20[15]v29=v20[16]v28=v20[17]v27=v20[18]v26=v20[19]v25=v20[20]v24=v20[21]v23=v20[22]v22=v20[23]v21=v20[24]v45 = -105* (39* (2* (v45 &amp; (-105* (39* (2 * (v34 &amp; (-105 * (39 * (2 * (v35 &amp; 3) + (v35 ^ 3)) + 23) + 111))+ (v34 ^ (-105 * (39 * (2 * (v35 &amp; 3) + (v35 ^ 3)) + 23) + 111)))+ 23)+ 111))+ (v45 ^ (-105* (39* (2 * (v34 &amp; (-105 * (39 * (2 * (v35 &amp; 3) + (v35 ^ 3)) + 23) + 111)) + (v34 ^ (-105 * (39 * (2 * (v35 &amp; 3) + (v35 ^ 3)) + 23) + 111))) + 23) + 111))) + 23)+ 111v44 = -105 * (39 * (2 * ((v32 ^ v31) &amp; v44) + (v32 ^ v31 ^ v44)) + 23) + 111v43 = -105* (39 * (2 * (v43 &amp; (-105 * (39 * (2 * (v31 &amp; v30) + (v31 ^ v30)) + 23) + 111)) + (v43 ^ (-105 * (39 * (2 * (v31 &amp; v30) + (v31 ^ v30)) + 23) + 111))) + 23)+ 111v42 = -105 * (39 * (2 * ((v28 ^ 0x17) &amp; v42) + (v28 ^ 0x17 ^ v42)) + 23) + 111v41 = -105* (39 * (2 * (v41 &amp; (-105 * (39 * (2 * (v25 &amp; (-105 * (39 * (2 * (v36 &amp; 0xFB) + (v36 ^ 0xFB)) + 23) + 111)) + (v25 ^ (-105 * (39 * (2 * (v36 &amp; 0xFB) + (v36 ^ 0xFB)) + 23) + 111))) + 23) + 111)) + (v41 ^ (-105 * (39 * (2 * (v25 &amp; (-105 * (39 * (2 * (v36 &amp; 0xFB) + (v36 ^ 0xFB)) + 23) + 111)) + (v25 ^ (-105 * (39 * (2 * (v36 &amp; 0xFB) + (v36 ^ 0xFB)) + 23) + 111))) + 23) + 111))) + 23)+ 111v40 = -105 * (39 * (2 * (v40 &amp; (~v22 + v24 + 1)) + (v40 ^ (~v22 + v24 + 1))) + 23) + 111v39 = -105* (39 * (2 * (v39 &amp; (-105 * (39 * (2 * (v37 &amp; v38) + (v37 ^ v38)) + 23) + 111)) + (v39 ^ (-105 * (39 * (2 * (v37 &amp; v38) + (v37 ^ v38)) + 23) + 111))) + 23)+ 111v38 = -105* (39 * (2 * (v38 &amp; (-105 * (39 * (2 * ((~v25 + v22 + 1) &amp; 0x11) + ((~v25 + v22 + 1) ^ 0x11)) + 23) + 111)) + (v38 ^ (-105 * (39 * (2 * ((~v25 + v22 + 1) &amp; 0x11) + ((~v25 + v22 + 1) ^ 0x11)) + 23) + 111))) + 23)+ 111v37 = -105* (39 * (2 * (v37 &amp; (v26 ^ (-105 * (39 * (2 * (v27 &amp; 1) + (v27 ^ 1)) + 23) + 111))) + (v37 ^ v26 ^ (-105 * (39 * (2 * (v27 &amp; 1) + (v27 ^ 1)) + 23) + 111))) + 23)+ 111v36 = ~v29 + -105 * (39 * (2 * (v28 &amp; v36) + (v28 ^ v36)) + 23) + 111 + 1v35 = -105* (39 * (2 * (v35 &amp; (-105 * (39 * (2 * (v31 &amp; v30) + (v31 ^ v30)) + 23) + 111)) + (v35 ^ (-105 * (39 * (2 * (v31 &amp; v30) + (v31 ^ v30)) + 23) + 111))) + 23)+ 111v34 = -105* (39 * (2 * (v33 &amp; (-105 * (39 * (2 * (v32 &amp; (-105 * (39 * (2 * (v34 &amp; 0xF9) + (v34 ^ 0xF9)) + 23) + 111)) + (v32 ^ (-105 * (39 * (2 * (v34 &amp; 0xF9) + (v34 ^ 0xF9)) + 23) + 111))) + 23) + 111)) + (v33 ^ (-105 * (39 * (2 * (v32 &amp; (-105 * (39 * (2 * (v34 &amp; 0xF9) + (v34 ^ 0xF9)) + 23) + 111)) + (v32 ^ (-105 * (39 * (2 * (v34 &amp; 0xF9) + (v34 ^ 0xF9)) + 23) + 111))) + 23) + 111))) + 23)+ 111v33 = -105 * (39 * (2 * (v33 &amp; v34) + (v33 ^ v34)) + 23) + 111v32 = -105 * (39 * (2 * (v32 &amp; (v38 ^ v37)) + (v32 ^ v38 ^ v37)) + 23) + 111v31 = -105* (39 * (2 * (v40 &amp; (-105 * (39 * (2 * (v41 &amp; (-105 * (39 * (2 * (v31 &amp; 0xC) + (v31 ^ 0xC)) + 23) + 111)) + (v41 ^ (-105 * (39 * (2 * (v31 &amp; 0xC) + (v31 ^ 0xC)) + 23) + 111))) + 23) + 111)) + (v40 ^ (-105 * (39 * (2 * (v41 &amp; (-105 * (39 * (2 * (v31 &amp; 0xC) + (v31 ^ 0xC)) + 23) + 111)) + (v41 ^ (-105 * (39 * (2 * (v31 &amp; 0xC) + (v31 ^ 0xC)) + 23) + 111))) + 23) + 111))) + 23)+ 111v30 = -105* (39 * (2 * (v42 &amp; (-105 * (39 * (2 * (v30 &amp; 8) + (v30 ^ 8)) + 23) + 111)) + (v42 ^ (-105 * (39 * (2 * (v30 &amp; 8) + (v30 ^ 8)) + 23) + 111))) + 23)+ 111v29 = -105 * (39 * (2 * ((v43 ^ 0x4D) &amp; v29) + (v43 ^ 0x4D ^ v29)) + 23) + 111v28 = -105* (39 * (2 * (v28 &amp; (-105 * (39 * (2 * ((v44 ^ 0x17) &amp; 0xF9) + (v44 ^ 0xEE)) + 23) + 111)) + (v28 ^ (-105 * (39 * (2 * ((v44 ^ 0x17) &amp; 0xF9) + (v44 ^ 0xEE)) + 23) + 111))) + 23)+ 111v27 = -105 * (39 * (2 * ((v28 ^ v30) &amp; v27) + (v28 ^ v30 ^ v27)) + 23) + 111v26 = -105* (39 * (2 * (v33 &amp; (-105 * (39 * (2 * (v31 &amp; v26) + (v31 ^ v26)) + 23) + 111)) + (v33 ^ (-105 * (39 * (2 * (v31 &amp; v26) + (v31 ^ v26)) + 23) + 111))) + 23)+ 111v25 = -105 * (39 * (2 * (v25 &amp; v34) + (v25 ^ v34)) + 23) + 111v24 = -105* (39 * (2 * (v37 &amp; (-105 * (39 * (2 * (v24 &amp; v39) + (v24 ^ v39)) + 23) + 111)) + (v37 ^ (-105 * (39 * (2 * (v24 &amp; v39) + (v24 ^ v39)) + 23) + 111))) + 23)+ 111v23 = -105 * (39 * (2 * (v40 &amp; v23) + (v40 ^ v23)) + 23) + 111v22 = -105 * (39 * (2 * ((v45 ^ v43) &amp; v22) + (v45 ^ v43 ^ v22)) + 23) + 111v21 = -105* (39 * (2 * (v21 &amp; (-105 * (39 * (2 * (v44 &amp; 0x18) + (v44 ^ 0x18)) + 23) + 111)) + (v21 ^ (-105 * (39 * (2 * (v44 &amp; 0x18) + (v44 ^ 0x18)) + 23) + 111))) + 23)+ 111v20[0]=v45v20[1]=v44v20[2]=v43v20[3]=v42v20[4]=v41v20[5]=v40v20[6]=v39v20[7]=v38v20[8]=v37v20[9]=v36v20[10]=v35v20[11]=v34v20[12]=v33v20[13]=v32v20[14]=v31v20[15]=v30v20[16]=v29v20[17]=v28v20[18]=v27v20[19]=v26v20[20]=v25v20[21]=v24v20[22]=v23v20[23]=v22v20[24]=v21for i in range(25): v20[i]&amp;=0xffnv20=[0]*25dword=[0x00000000, 0xFFFFFFFE, 0xFFFFFFFF, 0x00000004, 0x00000001, 0xFFFFFFFF, 0x00000001, 0x00000000, 0x00000000, 0xFFFFFFFF, 0xFFFFFFFD, 0xFFFFFFFE, 0x00000000, 0xFFFFFFF6, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE, 0x00000001, 0xFFFFFFF3, 0xFFFFFFFF, 0xFFFFFFFA, 0xFFFFFFFF, 0xFFFFFFFE, 0x00000001, 0xFFFFFFFE, 0x00000000, 0x00000000, 0x00000000]for i in range(5): for j in range(5): v13 = 0 for k in range(5): v3=((dword[5*i+k])*v20[5*k+j])&amp;0xff v9 = (-105 * (39 * (2 * (v13 &amp; v3) + (v13 ^ v3)) + 23) + 111)&amp;0xff v13 = v9 nv20[5*i+j]=v13enc=[118, 116, 245, 47, 83, 72, 116, 69, 164, 95, 252, 99, 1, 208, 248, 170, 121, 70, 17, 126, 29, 145, 126, 142, 202]for i in range(25): x.add(nv20[i]==enc[i])if x.check() == sat: model = x.model() print(model) NKCTF{THut_1Ss_s@_eAsyhh} EZNative用blutter的addNames.py和bindiff恢复符号表 容易看出是xxtea加密 动调找到密文密钥 看了眼算法没有魔改，但死活解不出来，一步一步跟汇编发现超过8字节没有溢出，刚好放出了提示，去搜了下xxtea dart 配置dart环境然后解密，刚配不知道怎么导库，直接把库粘进去 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/*--------------------------------------------------------*\\| || xxtea.dart || || XXTEA encryption algorithm library for Dart. || || Encryption Algorithm Authors: || David J. Wheeler || Roger M. Needham || || Code Author: Ma Bingyao &lt;mabingyao@gmail.com&gt; || LastModified: Mar 11, 2021 || |\\*________________________________________________________*/library xxtea;import &#x27;dart:convert&#x27;;import &#x27;dart:core&#x27;;import &#x27;dart:typed_data&#x27;;const xxtea = XXTEA();Uint8List? xxteaEncrypt(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) =&gt; xxtea.encrypt(data, key, includeLength: includeLength);Uint8List? xxteaDecrypt(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) =&gt; xxtea.decrypt(data, key, includeLength: includeLength);String? xxteaEncryptToString(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) =&gt; xxtea.encryptToString(data, key, includeLength: includeLength);String? xxteaDecryptToString(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) =&gt; xxtea.decryptToString(data, key, includeLength: includeLength);class XXTEA &#123; static const _DELTA = 0x9E3779B9; const XXTEA(); Uint8List? _toUint8List(Uint32List v, bool includeLength) &#123; final length = v.length; var n = length &lt;&lt; 2; if (includeLength) &#123; final m = v[length - 1]; n -= 4; if ((m &lt; n - 3) || (m &gt; n)) &#123; return null; &#125; n = m; &#125; final bytes = Uint8List(n); for (var i = 0; i &lt; n; ++i) &#123; bytes[i] = v[i &gt;&gt; 2] &gt;&gt; ((i &amp; 3) &lt;&lt; 3); &#125; return bytes; &#125; Uint32List _toUint32List(Uint8List bytes, includeLength) &#123; final length = bytes.length; var n = length &gt;&gt; 2; if ((length &amp; 3) != 0) ++n; Uint32List v; if (includeLength) &#123; v = Uint32List(n + 1); v[n] = length; &#125; else &#123; v = Uint32List(n); &#125; for (var i = 0; i &lt; length; ++i) &#123; v[i &gt;&gt; 2] |= bytes[i] &lt;&lt; ((i &amp; 3) &lt;&lt; 3); &#125; return v; &#125; int _mx(int sum, int y, int z, int p, int e, Uint32List k) &#123; return ((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (k[p &amp; 3 ^ e] ^ z)); &#125; Uint8List _fixkey(Uint8List key) &#123; if (key.length &lt; 16) &#123; final k = Uint8List(16); k.setAll(0, key); return k; &#125; return key.sublist(0, 16); &#125; int _int(int i) &#123; return i &amp; 0xFFFFFFFF; &#125; Uint32List _encryptUint32List(Uint32List v, Uint32List k) &#123; final length = v.length; final n = length - 1; var y, z, sum, e, p, q; z = v[n]; sum = 0; for (q = 6 + (52 ~/ length); q &gt; 0; --q) &#123; sum = _int(sum + _DELTA); e = sum &gt;&gt; 2 &amp; 3; for (p = 0; p &lt; n; ++p) &#123; y = v[p + 1]; z = v[p] = _int(v[p] + _mx(sum, y, z, p, e, k)); &#125; y = v[0]; z = v[n] = _int(v[n] + _mx(sum, y, z, p, e, k)); &#125; return v; &#125; Uint32List _decryptUint32List(Uint32List v, Uint32List k) &#123; final length = v.length; final n = length - 1; var y, z, sum, e, p, q; y = v[0]; q = 6 + (52 ~/ length); for (sum = _int(q * _DELTA); sum != 0; sum = _int(sum - _DELTA)) &#123; e = sum &gt;&gt; 2 &amp; 3; for (p = n; p &gt; 0; --p) &#123; z = v[p - 1]; y = v[p] = _int(v[p] - _mx(sum, y, z, p, e, k)); &#125; z = v[n]; y = v[0] = _int(v[0] - _mx(sum, y, z, p, e, k)); &#125; return v; &#125; Uint8List? encrypt(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) &#123; if (data is String) data = utf8.encode(data); if (key is String) key = utf8.encode(key); if (data == null || data.length == 0) &#123; return data; &#125; return _toUint8List( _encryptUint32List(_toUint32List(data, includeLength), _toUint32List(_fixkey(key), false)), false); &#125; String? encryptToString(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) &#123; final encrypted = encrypt(data, key, includeLength: includeLength); if (encrypted != null) &#123; return base64.encode(encrypted); &#125; &#125; Uint8List? decrypt(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) &#123; if (data is String) data = base64.decode(data); if (key is String) key = utf8.encode(key); if (data == null || data.length == 0) &#123; return data; &#125; return _toUint8List( _decryptUint32List( _toUint32List(data, false), _toUint32List(_fixkey(key), false)), includeLength); &#125; String? decryptToString(dynamic data, dynamic key, &#123;bool includeLength = true&#125;) &#123; final decrypted = decrypt(data, key, includeLength: includeLength); if (decrypted != null) &#123; return utf8.decode(decrypted); &#125; &#125;&#125;void main() &#123; String str = &quot;UAsFvs3tDyTxFPGb7WbyBYSm05VWrJxgjArj9mx490pfH1LO&quot;; String key = &quot;17a389e9efdad7ce&quot;; String? encrypt_data = xxtea.decryptToString(str, key); print(encrypt_data);&#125;"},{"title":"安装blutter","path":"/2024/06/22/安装blutter/","content":"安装blutter1git clone https://github.com/worawit/blutter --depth=1 然后安装依赖 12sudo apt install python3-pyelftools python3-requests git cmake ninja-buildpkg-config libicu-dev libcapstone-dev 遇到的几种报错和解决方法： 更新apt源就行 1sudo apt-get update 要全程挂代理才行 https://blog.csdn.net/qq_63701832/article/details/131426713 gcc版本低了，要gcc13 1sudo apt install gcc 成功，配了三天，人麻了"},{"title":"White-box AES","path":"/2024/06/22/White-box-AES/","content":"从网上找了一份aes源码进行白盒aes测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327import reimport binasciiclass AES:#128-ECB sbox = [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16] s_box = &#123;&#125; ns_box = &#123; &#125; Rcon = &#123; 1: [&#x27;0x01&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 2: [&#x27;0x02&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 3: [&#x27;0x04&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 4: [&#x27;0x08&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 5: [&#x27;0x10&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 6: [&#x27;0x20&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 7: [&#x27;0x40&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 8: [&#x27;0x80&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 9: [&#x27;0x1B&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;], 10: [&#x27;0x36&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;, &#x27;0x00&#x27;] &#125; Matrix = [ [&#x27;0x02&#x27;, &#x27;0x03&#x27;, &#x27;0x01&#x27;, &#x27;0x01&#x27;], [&#x27;0x01&#x27;, &#x27;0x02&#x27;, &#x27;0x03&#x27;, &#x27;0x01&#x27;], [&#x27;0x01&#x27;, &#x27;0x01&#x27;, &#x27;0x02&#x27;, &#x27;0x03&#x27;], [&#x27;0x03&#x27;, &#x27;0x01&#x27;, &#x27;0x01&#x27;, &#x27;0x02&#x27;] ] ReMatrix = [ [&#x27;0x0e&#x27;, &#x27;0x0b&#x27;, &#x27;0x0d&#x27;, &#x27;0x09&#x27;], [&#x27;0x09&#x27;, &#x27;0x0e&#x27;, &#x27;0x0b&#x27;, &#x27;0x0d&#x27;], [&#x27;0x0d&#x27;, &#x27;0x09&#x27;, &#x27;0x0e&#x27;, &#x27;0x0b&#x27;], [&#x27;0x0b&#x27;, &#x27;0x0d&#x27;, &#x27;0x09&#x27;, &#x27;0x0e&#x27;] ] plaintext = [[], [], [], []] plaintext1 = [[], [], [], []] subkey = [[], [], [], []] def __init__(self, key):#密钥扩展 self.s_box = dict(zip([&quot;0x%02x&quot;%i for i in range(256)], [&quot;0x%02x&quot;%i for i in self.sbox])) self.ns_box = dict(zip(self.s_box.values(), self.s_box.keys())) for i in range(4): for j in range(0, 8, 2): self.subkey[i].append(&quot;0x&quot; + key[i * 8 + j:i * 8 + j + 2]) # print(self.subkey) for i in range(4, 44): if i % 4 != 0: tmp = xor_32(self.subkey[i - 1], self.subkey[i - 4],0) self.subkey.append(tmp) else: # 4的倍数的时候执行 tmp1 = self.subkey[i - 1][1:] tmp1.append(self.subkey[i - 1][0]) # print(tmp1) for m in range(4): tmp1[m] = self.s_box[tmp1[m]] # tmp1 = self.s_box[&#x27;cf&#x27;] tmp1 = xor_32(tmp1, self.Rcon[i / 4], 0) self.subkey.append(xor_32(tmp1, self.subkey[i - 4],0)) def AddRoundKey(self, round):#轮密钥加 for i in range(4): self.plaintext[i] = xor_32(self.plaintext[i], self.subkey[round * 4 + i],0) # print(&#x27;AddRoundKey&#x27;,self.plaintext) def PlainSubBytes(self): for i in range(4): for j in range(4): self.plaintext[i][j] = self.s_box[self.plaintext[i][j]] # print(&#x27;PlainSubBytes&#x27;,self.plaintext) def RePlainSubBytes(self): for i in range(4): for j in range(4): self.plaintext[i][j] = self.ns_box[self.plaintext[i][j]] def ShiftRows(self):#行移位 p1, p2, p3, p4 = self.plaintext[0][1], self.plaintext[1][1], self.plaintext[2][1], self.plaintext[3][1] self.plaintext[0][1] = p2 self.plaintext[1][1] = p3 self.plaintext[2][1] = p4 self.plaintext[3][1] = p1 p1, p2, p3, p4 = self.plaintext[0][2], self.plaintext[1][2], self.plaintext[2][2], self.plaintext[3][2] self.plaintext[0][2] = p3 self.plaintext[1][2] = p4 self.plaintext[2][2] = p1 self.plaintext[3][2] = p2 p1, p2, p3, p4 = self.plaintext[0][3], self.plaintext[1][3], self.plaintext[2][3], self.plaintext[3][3] self.plaintext[0][3] = p4 self.plaintext[1][3] = p1 self.plaintext[2][3] = p2 self.plaintext[3][3] = p3 # print(&#x27;ShiftRows&#x27;,self.plaintext) def ReShiftRows(self): p1, p2, p3, p4 = self.plaintext[0][1], self.plaintext[1][1], self.plaintext[2][1], self.plaintext[3][1] self.plaintext[3][1] = p3 self.plaintext[2][1] = p2 self.plaintext[0][1] = p4 self.plaintext[1][1] = p1 p1, p2, p3, p4 = self.plaintext[0][2], self.plaintext[1][2], self.plaintext[2][2], self.plaintext[3][2] self.plaintext[0][2] = p3 self.plaintext[1][2] = p4 self.plaintext[2][2] = p1 self.plaintext[3][2] = p2 p1, p2, p3, p4 = self.plaintext[0][3], self.plaintext[1][3], self.plaintext[2][3], self.plaintext[3][3] self.plaintext[0][3] = p2 self.plaintext[1][3] = p3 self.plaintext[2][3] = p4 self.plaintext[3][3] = p1 def MixColumns(self):#列混淆 for i in range(4): for j in range(4): self.plaintext1[i].append(MatrixMulti(self.Matrix[j], self.plaintext[i])) # print(&#x27;MixColumns&#x27;,self.plaintext1) def ReMixColumns(self): for i in range(4): for j in range(4): self.plaintext1[i].append(MatrixMulti(self.ReMatrix[j], self.plaintext[i])) def AESEncryption(self, plaintext,wb): self.plaintext = [[], [], [], []] for i in range(4): for j in range(0, 8, 2): self.plaintext[i].append(&quot;0x&quot; + plaintext[i * 8 + j:i * 8 + j + 2]) self.AddRoundKey(0) for i in range(9): if wb!=-1 and i==8: self.plaintext[wb//4][wb%4]=&#x27;0x01&#x27; self.PlainSubBytes() self.ShiftRows() self.MixColumns() self.plaintext = self.plaintext1 self.plaintext1 = [[], [], [], []] self.AddRoundKey(i + 1) self.PlainSubBytes() self.ShiftRows() self.AddRoundKey(10) return Matrixtostr(self.plaintext) def AESDecryption(self, cipher): self.plaintext = [[], [], [], []] for i in range(4): for j in range(0, 8, 2): self.plaintext[i].append(&#x27;0x&#x27; + cipher[i * 8 + j:i * 8 + j + 2]) # print(self.ns_box) self.AddRoundKey(10) for i in range(9): self.ReShiftRows() self.RePlainSubBytes() self.AddRoundKey(9-i) self.ReMixColumns() self.plaintext = self.plaintext1 self.plaintext1 = [[], [], [], []] self.ReShiftRows() self.RePlainSubBytes() self.AddRoundKey(0) return Matrixtostr(self.plaintext) def Encryption(self, text,wb=-1): group = PlaintextGroup(TextToByte(text), 32, 1) # print(group) cipher = &quot;&quot; for i in range(len(group)): cipher = cipher + self.AESEncryption(group[i],wb) return cipher def Decryption(self, cipher): group = PlaintextGroup(cipher, 32, 0) # print(group) text = &#x27;&#x27; for i in range(len(group)): text = text + self.AESDecryption(group[i]) text = ByteToText(text) return textdef xor_32(start, end, key): a = [] for i in range(0, 4): xor_tmp = &quot;&quot; b = hextobin(start[i]) c = hextobin(end[i]) d = bin(key)[2:].rjust(8,&#x27;0&#x27;) for j in range(8): tmp = int(b[j], 10) ^ int(c[j], 10) ^ int(d[j],10) xor_tmp += str(tmp ) a.append(bintohex(xor_tmp)) return adef xor_8(begin, end): xor_8_tmp = &quot;&quot; for i in range(8): xor_8_tmp += str(int(begin[i]) ^ int(end[i])) return xor_8_tmpdef hextobin(word): word = bin(int(word, 16))[2:] for i in range(0, 8-len(word)): word = &#x27;0&#x27;+word return worddef bintohex(word): word = hex(int(word, 2)) if len(word) == 4: return word elif len(word) &lt; 4: return word.replace(&#x27;x&#x27;, &#x27;x0&#x27;)def MatrixMulti(s1, s2): result = [] s3 = [] for i in range(4): s3.append(hextobin(s2[i])) for i in range(4): result.append(MultiProcess(int(s1[i], 16), s3[i])) for i in range(3): result[0] = xor_8(result[0], result[i+1]) return bintohex(result[0])def MultiProcess(a, b): if a == 1: return b elif a == 2: if b[0] == &#x27;0&#x27;: b = b[1:] + &#x27;0&#x27; else: b = b[1:] + &#x27;0&#x27; b = xor_8(b, &#x27;00011011&#x27;) return b elif a == 3: tmp_b = b if b[0] == &#x27;0&#x27;: b = b[1:] + &#x27;0&#x27; else: b = b[1:] + &#x27;0&#x27; b = xor_8(b, &#x27;00011011&#x27;) return xor_8(b, tmp_b) elif a == 9: tmp_b = b return xor_8(tmp_b, MultiProcess(2, MultiProcess(2, MultiProcess(2, b)))) elif a == 11: tmp_b = b return xor_8(tmp_b, xor_8(MultiProcess(2, MultiProcess(2, MultiProcess(2, b))), MultiProcess(2, b))) elif a == 13: tmp_b = b return xor_8(tmp_b, xor_8(MultiProcess(2, MultiProcess(2, MultiProcess(2, b))), MultiProcess(2, MultiProcess(2, b)))) elif a == 14: return xor_8(MultiProcess(2, b), xor_8(MultiProcess(2, MultiProcess(2, MultiProcess(2, b))), MultiProcess(2, MultiProcess(2, b))))def Matrixtostr(matrix): result = &quot;&quot; for i in range(4): for j in range(4): result += matrix[i][j][2:] return resultdef PlaintextGroup(plaintext, length, flag): group = re.findall(&#x27;.&#123;&#x27;+str(length)+&#x27;&#125;&#x27;, plaintext) group.append(plaintext[len(group)*length:]) if group[-1] == &#x27;&#x27; and flag: group[-1] = &#x27;16161616161616161616161616161616&#x27; elif len(group[-1]) &lt; length and flag: tmp = int((length-len(group[-1])) / 2) if tmp &lt; 10: for i in range(tmp): group[-1] = group[-1] + &#x27;0&#x27;+str(tmp) else: for i in range(tmp): group[-1] = group[-1] + str(tmp) elif not flag: del group[-1] return group#字符串转16进制def TextToByte(words): text = words.encode(&#x27;utf-8&#x27;).hex() return textdef ByteToText(encode): tmp = int(encode[-2:]) word = &#x27;&#x27; for i in range(len(encode)-tmp*2): word = word + encode[i] # print(word) word = bytes.decode(binascii.a2b_hex(word)) return word#字节非轮异或def xorbytes(bytes1,bytes2): length=min(len(bytes1),len(bytes2)) output=bytearray() for i in range(length): output.append(bytes1[i]^bytes2[i]) return bytes(output)key = &#x27;&#x27;for i in &quot;16uopAJc9tgxYSWO&quot;: key+=hex(ord(i))[2:].rjust(2,&quot;0&quot;)A1 = AES(key)print(A1.Encryption(&quot;asdfghjklasdfghj&quot;)[0:32])for i in range(16): print(A1.Encryption(&quot;asdfghjklasdfghj&quot;,i)[0:32]) 测试密钥:16uopAJc9tgxYSWO（3136756f70414a63397467785953574f） 这里应该当作不知道密钥的值，通过DAF攻击还原密钥 在第9轮加密时候构造缺陷数据（改变密文的一个字节） 获取正确密文和构造缺陷数据时的密文，需要对密文16个字节都进行一次构造缺陷数据 容易看出每一组构造缺陷数据得到的密文和正确的密文只有4个字节不同 通过获得的1+16组密文通过phoenixAES获取第十轮密钥 12345678910111213141516171819202122232425import phoenixAESdata = &quot;&quot;&quot;6c2baf57aeb663a830eaee17bcdb5894d32baf57aeb6637a30ea0c17bc2458946c2baff2aeb623a83018ee17b9db58946c2b6157ae0063a8e3eaee17bcdb583c6c71af579cb663a830eaee3abcdb6a946ca5af57f1b663a830eaeebbbcdbff94972baf57aeb6634530ea8d17bcd158946c2baf8baeb6dba83095ee17f1db58946c2b1b57ae7563a8f3eaee17bcdb580d6c2b3c57ae9d63a867eaee17bcdb584f6ccfaf57adb663a830eaee4fbcdb3d949b2baf57aeb663af30ead717bc8058946c2baf67aeb65ea83086ee17eddb58946c2baf29aeb637a8304aee170adb58946c2b4357ae9463a892eaee17bcdb58b86c9eaf572eb663a830eaeeaebcdb2e94fe2baf57aeb6639a30eae917bcb55894&quot;&quot;&quot;with open(&#x27;crackfile&#x27;, &#x27;w&#x27;) as fp: fp.write(data)phoenixAES.crack_file(&#x27;crackfile&#x27;, [], True, False, verbose=2) 出现以下内容表示成功获取第十轮的密钥 然后用Stark还原原始密钥 发现成功还原出原始密钥"}]